; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Users\paind_000\Dysk Google\Grzesiek\Dokumenty\STUDIA\JA\Projekt\Hasla\Hasla\Program.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_startTime
PUBLIC	_endTime
PUBLIC	_resultTime
PUBLIC	_endTimefull
PUBLIC	_startTimefull
PUBLIC	_CPUInfo
PUBLIC	_bSSE41Extensions
PUBLIC	_bSSE42Extensions
PUBLIC	_nLogicalProcessors
PUBLIC	_nFeatureInfo
PUBLIC	_bMultithreading
_BSS	SEGMENT
_startTime DD	01H DUP (?)
_endTime DD	01H DUP (?)
_resultTime DD	01H DUP (?)
_endTimefull DD	01H DUP (?)
_startTimefull DD 01H DUP (?)
_bSSE41Extensions DB 01H DUP (?)
	ALIGN	4

_bSSE42Extensions DB 01H DUP (?)
	ALIGN	4

_nLogicalProcessors DD 01H DUP (?)
_nFeatureInfo DD 01H DUP (?)
_bMultithreading DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_CPUInfo DD	0ffffffffH
	ORG $+12
_DATA	ENDS
PUBLIC	_GetNameOfFile
PUBLIC	_getSearchedWord
PUBLIC	_findAllEntries
PUBLIC	_findAllEntriesCounted
PUBLIC	_output
PUBLIC	_outputDatabaseScreen
PUBLIC	_outputDatabaseFile
PUBLIC	_clean
PUBLIC	_startProgram
PUBLIC	_startProgramWithThreads
PUBLIC	_setPointers
PUBLIC	_searchThreadCounted@4
PUBLIC	_searchThreadUncounted@4
PUBLIC	_readNumberOfLogicalUnits
PUBLIC	_chartowchar
PUBLIC	_wchartochar
PUBLIC	??_C@_0O@FIENMJNC@Brak?5wynikow?$CB?$AA@	; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@		; `string'
PUBLIC	??_C@_0L@FADCIPKF@data?2A?4txt?$AA@		; `string'
PUBLIC	??_C@_1CE@MCHMMFAB@?$AAT?$AAr?$AAy?$AAb?$AA?5?$AAn?$AAo?$AAr?$AAm?$AAa?$AAl?$AAn?$AAy?$AA?4?$AA?4?$AA?5?$AA?6?$AA?$AA@ ; `string'
PUBLIC	??_C@_17MJEANDKP@?$AA?$CF?$AAs?$AA?6?$AA?$AA@	; `string'
PUBLIC	??_C@_1EC@ENMCEKOI@?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AA?$CF?$AAd?$AA?5?$AAu?$AAn?$AAi?$AAt?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?6@ ; `string'
PUBLIC	??_C@_1CC@JMHMOHGF@?$AAT?$AAr?$AAy?$AAb?$AA?5?$AAs?$AAz?$AAy?$AAb?$AAk?$AAi?$AA?4?$AA?4?$AA?4?$AA?5?$AA?6?$AA?$AA@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp___itoa:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fputs:PROC
EXTRN	__imp__puts:PROC
EXTRN	__imp__fputwc:PROC
EXTRN	__imp__fputws:PROC
EXTRN	__imp__fwprintf:PROC
EXTRN	__imp___beginthreadex:PROC
EXTRN	__imp___endthreadex:PROC
EXTRN	__imp__compare:PROC
EXTRN	_newEntry:PROC
EXTRN	_addEntryToList:PROC
EXTRN	_readEntriesFromFile:PROC
EXTRN	_getNumberOfEntries:PROC
EXTRN	_setPackage:PROC
EXTRN	_deletePackage:PROC
EXTRN	_openFileAndGetNumberOfElements:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1CC@JMHMOHGF@?$AAT?$AAr?$AAy?$AAb?$AA?5?$AAs?$AAz?$AAy?$AAb?$AAk?$AAi?$AA?4?$AA?4?$AA?4?$AA?5?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@JMHMOHGF@?$AAT?$AAr?$AAy?$AAb?$AA?5?$AAs?$AAz?$AAy?$AAb?$AAk?$AAi?$AA?4?$AA?4?$AA?4?$AA?5?$AA?6?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'y', 00H, 'b', 00H, ' ', 00H, 's', 00H, 'z', 00H
	DB	'y', 00H, 'b', 00H, 'k', 00H, 'i', 00H, '.', 00H, '.', 00H, '.'
	DB	00H, ' ', 00H, 0aH, 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@ENMCEKOI@?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AA?$CF?$AAd?$AA?5?$AAu?$AAn?$AAi?$AAt?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?6@
CONST	SEGMENT
??_C@_1EC@ENMCEKOI@?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AA?$CF?$AAd?$AA?5?$AAu?$AAn?$AAi?$AAt?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?6@ DB 'E'
	DB	00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '%', 00H
	DB	'd', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'i', 00H, 't', 00H, 's'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 'd', 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17MJEANDKP@?$AA?$CF?$AAs?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_17MJEANDKP@?$AA?$CF?$AAs?$AA?6?$AA?$AA@ DB '%', 00H, 's', 00H, 0aH, 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@MCHMMFAB@?$AAT?$AAr?$AAy?$AAb?$AA?5?$AAn?$AAo?$AAr?$AAm?$AAa?$AAl?$AAn?$AAy?$AA?4?$AA?4?$AA?5?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@MCHMMFAB@?$AAT?$AAr?$AAy?$AAb?$AA?5?$AAn?$AAo?$AAr?$AAm?$AAa?$AAl?$AAn?$AAy?$AA?4?$AA?4?$AA?5?$AA?6?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'y', 00H, 'b', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	'r', 00H, 'm', 00H, 'a', 00H, 'l', 00H, 'n', 00H, 'y', 00H, '.'
	DB	00H, '.', 00H, ' ', 00H, 0aH, 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@
CONST	SEGMENT
??_C@_0L@FADCIPKF@data?2A?4txt?$AA@ DB 'data\A.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@ DB 0aH, 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FIENMJNC@Brak?5wynikow?$CB?$AA@
CONST	SEGMENT
??_C@_0O@FIENMJNC@Brak?5wynikow?$CB?$AA@ DB 'Brak wynikow!', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _wchartochar
_TEXT	SEGMENT
$T1 = -324						; size = 4
_buf$ = -120						; size = 100
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_wchartochar PROC					; COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-328]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 345  : 	int i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN4@wchartocha:

; 346  : 	char buf[100];
; 347  : 	while(name[i]!='\0')

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	SHORT $LN3@wchartocha

; 348  : 	{	
; 349  : 		if(name[i]==L'\\')

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _name$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN2@wchartocha

; 350  : 			buf[i]='\\';

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _buf$[ebp+eax], 92		; 0000005cH
	jmp	SHORT $LN1@wchartocha
$LN2@wchartocha:

; 351  : 		else buf[i]=(char)name[i];	

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _name$[ebp]
	mov	cl, BYTE PTR [edx+ecx*2]
	mov	BYTE PTR _buf$[ebp+eax], cl
$LN1@wchartocha:

; 352  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 353  : 	}

	jmp	SHORT $LN4@wchartocha
$LN3@wchartocha:

; 354  : 	buf[i]='\0';

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 100			; 00000064H
	jae	SHORT $LN7@wchartocha
	jmp	SHORT $LN8@wchartocha
$LN7@wchartocha:
	call	___report_rangecheckfailure
$LN8@wchartocha:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _buf$[ebp+ecx], 0

; 355  : 	return buf;

	lea	eax, DWORD PTR _buf$[ebp]
$LN6@wchartocha:

; 356  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@wchartocha
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN11@wchartocha:
	DD	1
	DD	$LN10@wchartocha
$LN10@wchartocha:
	DD	-120					; ffffff88H
	DD	100					; 00000064H
	DD	$LN9@wchartocha
$LN9@wchartocha:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
_wchartochar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _chartowchar
_TEXT	SEGMENT
_j$ = -32						; size = 4
_i$ = -20						; size = 4
_tab2$ = -8						; size = 4
_tab$ = 8						; size = 4
_chartowchar PROC					; COMDAT

; 331  : {//convert given char * to wchar_t * (created because of Unicode code)

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 332  : 	wchar_t * tab2= (wchar_t *) malloc(sizeof(wchar_t) * 100);

	mov	esi, esp
	push	200					; 000000c8H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tab2$[ebp], eax

; 333  : 	int i=0,j=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
$LN2@chartowcha:

; 334  : 	while(tab[i]!='\0')

	mov	eax, DWORD PTR _tab$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@chartowcha

; 335  : 	{		
; 336  : 		tab2[i]=tab[i];

	mov	eax, DWORD PTR _tab$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	cx, BYTE PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _tab2$[ebp]
	mov	WORD PTR [eax+edx*2], cx

; 337  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 338  : 	}

	jmp	SHORT $LN2@chartowcha
$LN1@chartowcha:

; 339  : 	tab2[i]='\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _tab2$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 340  : 	return tab2;	

	mov	eax, DWORD PTR _tab2$[ebp]

; 341  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_chartowchar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _readNumberOfLogicalUnits
_TEXT	SEGMENT
_readNumberOfLogicalUnits PROC				; COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 325  : 	__cpuid(CPUInfo,1);

	mov	eax, 1
	xor	ecx, ecx
	cpuid
	mov	esi, OFFSET _CPUInfo
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx

; 326  : 	//return ((CPUInfo[1] >> 16) & 0xff)-1;
; 327  : 	return 8;

	mov	eax, 8

; 328  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_readNumberOfLogicalUnits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _searchThreadUncounted@4
_TEXT	SEGMENT
_database$ = -32					; size = 4
_results$ = -20						; size = 4
_pack$ = -8						; size = 4
_arg$ = 8						; size = 4
_searchThreadUncounted@4 PROC				; COMDAT

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 310  : 	Package * pack=(Package *)arg;

	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _pack$[ebp], eax

; 311  : 	Entry * results=NULL, * database=NULL;	

	mov	DWORD PTR _results$[ebp], 0
	mov	DWORD PTR _database$[ebp], 0

; 312  : 
; 313  : 	database=readEntriesFromFile(pack->fileptr,wcslen(pack->word));

	mov	esi, esp
	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__wcslen
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_readEntriesFromFile
	add	esp, 8
	mov	DWORD PTR _database$[ebp], eax

; 314  : 	results=findAllEntries(pack->word,database);

	mov	eax, DWORD PTR _database$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_findAllEntries
	add	esp, 8
	mov	DWORD PTR _results$[ebp], eax

; 315  : 	pack->results=results;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _results$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 316  : 	fclose(pack->fileptr);

	mov	esi, esp
	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 317  : 	pack->fileptr=NULL;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	DWORD PTR [eax+4], 0

; 318  : 	_endthreadex(0);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp___endthreadex
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 319  : 
; 320  : 	return 0;

	xor	eax, eax

; 321  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_searchThreadUncounted@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _searchThreadCounted@4
_TEXT	SEGMENT
_results$ = -20						; size = 4
_pack$ = -8						; size = 4
_arg$ = 8						; size = 4
_searchThreadCounted@4 PROC				; COMDAT

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 298  : 	Package * pack=(Package *)arg;

	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _pack$[ebp], eax

; 299  : 	Entry * results=NULL;	

	mov	DWORD PTR _results$[ebp], 0

; 300  : 
; 301  : 	results=findAllEntriesCounted(pack->word,pack->database,pack->counter);

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_findAllEntriesCounted
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _results$[ebp], eax

; 302  : 	pack->results=results;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _results$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 303  : 	_endthreadex(0);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp___endthreadex
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 304  : 
; 305  : 	return 0;

	xor	eax, eax

; 306  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_searchThreadCounted@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _setPointers
_TEXT	SEGMENT
_counter$ = -44						; size = 4
_i$ = -32						; size = 4
_tmp$ = -20						; size = 4
_tab$ = -8						; size = 4
_database$ = 8						; size = 4
_indicators$ = 12					; size = 4
_setPointers PROC					; COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 279  : 	Entry ** tab=(Entry **) calloc(nLogicalProcessors,sizeof(Entry *));

	mov	esi, esp
	push	4
	mov	eax, DWORD PTR _nLogicalProcessors
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tab$[ebp], eax

; 280  : 	Entry * tmp=database;

	mov	eax, DWORD PTR _database$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 281  : 	int i=0, counter=1;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _counter$[ebp], 1

; 282  : 
; 283  : 	for(;i<nLogicalProcessors;i++)

	jmp	SHORT $LN5@setPointer
$LN4@setPointer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@setPointer:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nLogicalProcessors
	jge	SHORT $LN3@setPointer
$LN2@setPointer:

; 284  : 	{
; 285  : 		while(counter<*(indicators[i]))

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _indicators$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _counter$[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN1@setPointer

; 286  : 		{
; 287  : 			tmp=tmp->next;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmp$[ebp], ecx

; 288  : 			counter++;

	mov	eax, DWORD PTR _counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$[ebp], eax

; 289  : 		}

	jmp	SHORT $LN2@setPointer
$LN1@setPointer:

; 290  : 		tab[i]=tmp;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tab$[ebp]
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 291  : 	}

	jmp	SHORT $LN4@setPointer
$LN3@setPointer:

; 292  : 
; 293  : 	return tab;

	mov	eax, DWORD PTR _tab$[ebp]

; 294  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_setPointers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _startProgramWithThreads
_TEXT	SEGMENT
tv79 = -344						; size = 4
_database$ = -144					; size = 4
_packages$ = -132					; size = 4
_hThreads$ = -120					; size = 4
_filename$ = -108					; size = 4
_threadid$ = -96					; size = 4
_lastfor$ = -84						; size = 4
_counter$ = -72						; size = 4
_threadcounter$ = -60					; size = 4
_listlength$ = -48					; size = 4
_results$ = -36						; size = 4
_fileptr2$ = -24					; size = 4
_fileptr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_wordtofind$ = 8					; size = 4
_outputfilename$ = 12					; size = 4
_startProgramWithThreads PROC				; COMDAT

; 162  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-344]
	mov	ecx, 86					; 00000056H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 163  : 	FILE * fileptr=NULL,*fileptr2=NULL;

	mov	DWORD PTR _fileptr$[ebp], 0
	mov	DWORD PTR _fileptr2$[ebp], 0

; 164  : 	Entry *results=NULL;

	mov	DWORD PTR _results$[ebp], 0

; 165  : 	int listlength=0, threadcounter=0, counter=0, lastfor=nLogicalProcessors=readNumberOfLogicalUnits();

	mov	DWORD PTR _listlength$[ebp], 0
	mov	DWORD PTR _threadcounter$[ebp], 0
	mov	DWORD PTR _counter$[ebp], 0
	call	_readNumberOfLogicalUnits
	mov	DWORD PTR _nLogicalProcessors, eax
	mov	eax, DWORD PTR _nLogicalProcessors
	mov	DWORD PTR _lastfor$[ebp], eax

; 166  : 	unsigned int threadid=0;

	mov	DWORD PTR _threadid$[ebp], 0

; 167  : 	char * filename=(char *)malloc(sizeof(char) * 100);

	mov	esi, esp
	push	100					; 00000064H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _filename$[ebp], eax

; 168  : 	HANDLE ** hThreads=(HANDLE **)calloc(nLogicalProcessors,sizeof(HANDLE *));

	mov	esi, esp
	push	4
	mov	eax, DWORD PTR _nLogicalProcessors
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hThreads$[ebp], eax

; 169  : 	Package ** packages=(Package **)calloc(nLogicalProcessors,sizeof(Package *));

	mov	esi, esp
	push	4
	mov	eax, DWORD PTR _nLogicalProcessors
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _packages$[ebp], eax

; 170  : 	Entry ** database=(Entry **) calloc(nLogicalProcessors,sizeof(Entry *));

	mov	esi, esp
	push	4
	mov	eax, DWORD PTR _nLogicalProcessors
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _database$[ebp], eax

; 171  : 	
; 172  : 	strcpy(filename,STORE_START);

	push	OFFSET ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 173  : 	nLogicalProcessors=(nLogicalProcessors==0 ? 1 : nLogicalProcessors);

	cmp	DWORD PTR _nLogicalProcessors, 0
	jne	SHORT $LN21@startProgr
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN22@startProgr
$LN21@startProgr:
	mov	eax, DWORD PTR _nLogicalProcessors
	mov	DWORD PTR tv79[ebp], eax
$LN22@startProgr:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _nLogicalProcessors, ecx

; 174  : 	fwprintf(stdout,L"Tryb szybki... \n");

	mov	esi, esp
	push	OFFSET ??_C@_1CC@JMHMOHGF@?$AAT?$AAr?$AAy?$AAb?$AA?5?$AAs?$AAz?$AAy?$AAb?$AAk?$AAi?$AA?4?$AA?4?$AA?4?$AA?5?$AA?6?$AA?$AA@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	add	eax, ecx
	push	eax
	call	DWORD PTR __imp__fwprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 175  : 	startTimefull=timeGetTime();

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _startTimefull, eax
$LN18@startProgr:

; 176  : 	while(1)

	mov	eax, 1
	test	eax, eax
	je	$LN17@startProgr
$LN16@startProgr:

; 177  : 	{
; 178  : 		while(threadcounter < nLogicalProcessors)

	mov	eax, DWORD PTR _threadcounter$[ebp]
	cmp	eax, DWORD PTR _nLogicalProcessors
	jge	$LN15@startProgr

; 179  : 		{
; 180  : 			fwprintf(stdout,L"%s\n",chartowchar(filename));

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_chartowchar
	add	esp, 4
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_17MJEANDKP@?$AA?$CF?$AAs?$AA?6?$AA?$AA@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	add	eax, ecx
	push	eax
	call	DWORD PTR __imp__fwprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 181  : 			fileptr=openFileAndGetNumberOfElements(filename,&listlength);

	lea	eax, DWORD PTR _listlength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_openFileAndGetNumberOfElements
	add	esp, 8
	mov	DWORD PTR _fileptr$[ebp], eax

; 182  : 			hThreads[threadcounter]=(HANDLE *)malloc(sizeof(HANDLE));

	mov	esi, esp
	push	4
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _threadcounter$[ebp]
	mov	edx, DWORD PTR _hThreads$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 183  : 			packages[threadcounter]=setPackage(wordtofind,NULL,NULL,fileptr,0);

	push	0
	mov	eax, DWORD PTR _fileptr$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _wordtofind$[ebp]
	push	ecx
	call	_setPackage
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _threadcounter$[ebp]
	mov	ecx, DWORD PTR _packages$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 184  : 			if(fileptr!=NULL)

	cmp	DWORD PTR _fileptr$[ebp], 0
	je	SHORT $LN14@startProgr

; 185  : 				*hThreads[threadcounter]=(HANDLE) _beginthreadex(NULL,0,searchThreadUncounted,(void *)packages[threadcounter],0,&threadid);

	mov	esi, esp
	lea	eax, DWORD PTR _threadid$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _threadcounter$[ebp]
	mov	edx, DWORD PTR _packages$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	OFFSET _searchThreadUncounted@4
	push	0
	push	0
	call	DWORD PTR __imp___beginthreadex
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _threadcounter$[ebp]
	mov	edx, DWORD PTR _hThreads$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN13@startProgr
$LN14@startProgr:

; 186  : 			else *hThreads[threadcounter]=0;

	mov	eax, DWORD PTR _threadcounter$[ebp]
	mov	ecx, DWORD PTR _hThreads$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx], 0
$LN13@startProgr:

; 187  : 
; 188  : 			counter++;

	mov	eax, DWORD PTR _counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$[ebp], eax

; 189  : 			threadcounter++;

	mov	eax, DWORD PTR _threadcounter$[ebp]
	add	eax, 1
	mov	DWORD PTR _threadcounter$[ebp], eax

; 190  : 			filename[5]++;			

	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _filename$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	add	dl, 1
	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _filename$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 191  : 			if(filename[5]>'Z')

	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _filename$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $LN12@startProgr

; 192  : 			{
; 193  : 				lastfor=threadcounter;

	mov	eax, DWORD PTR _threadcounter$[ebp]
	mov	DWORD PTR _lastfor$[ebp], eax

; 194  : 				break;

	jmp	SHORT $LN15@startProgr
$LN12@startProgr:

; 195  : 			}
; 196  : 		}

	jmp	$LN16@startProgr
$LN15@startProgr:

; 197  : 
; 198  : 		for(threadcounter=0;(threadcounter < nLogicalProcessors) && (threadcounter < lastfor)  ; threadcounter++)

	mov	DWORD PTR _threadcounter$[ebp], 0
	jmp	SHORT $LN11@startProgr
$LN10@startProgr:
	mov	eax, DWORD PTR _threadcounter$[ebp]
	add	eax, 1
	mov	DWORD PTR _threadcounter$[ebp], eax
$LN11@startProgr:
	mov	eax, DWORD PTR _threadcounter$[ebp]
	cmp	eax, DWORD PTR _nLogicalProcessors
	jge	SHORT $LN9@startProgr
	mov	eax, DWORD PTR _threadcounter$[ebp]
	cmp	eax, DWORD PTR _lastfor$[ebp]
	jge	SHORT $LN9@startProgr

; 199  : 		{
; 200  : 			WaitForSingleObject(*hThreads[threadcounter],INFINITE);

	mov	esi, esp
	push	-1
	mov	eax, DWORD PTR _threadcounter$[ebp]
	mov	ecx, DWORD PTR _hThreads$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 201  : 		}

	jmp	SHORT $LN10@startProgr
$LN9@startProgr:

; 202  : 
; 203  : 		for(threadcounter=0;(threadcounter < nLogicalProcessors) && (threadcounter < lastfor); threadcounter++)

	mov	DWORD PTR _threadcounter$[ebp], 0
	jmp	SHORT $LN8@startProgr
$LN7@startProgr:
	mov	eax, DWORD PTR _threadcounter$[ebp]
	add	eax, 1
	mov	DWORD PTR _threadcounter$[ebp], eax
$LN8@startProgr:
	mov	eax, DWORD PTR _threadcounter$[ebp]
	cmp	eax, DWORD PTR _nLogicalProcessors
	jge	$LN6@startProgr
	mov	eax, DWORD PTR _threadcounter$[ebp]
	cmp	eax, DWORD PTR _lastfor$[ebp]
	jge	$LN6@startProgr

; 204  : 		{
; 205  : 			results=addEntryToList(packages[threadcounter]->results,results);

	mov	eax, DWORD PTR _results$[ebp]
	push	eax
	mov	ecx, DWORD PTR _threadcounter$[ebp]
	mov	edx, DWORD PTR _packages$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_addEntryToList
	add	esp, 8
	mov	DWORD PTR _results$[ebp], eax

; 206  : 			if(*hThreads[threadcounter]!=0)

	mov	eax, DWORD PTR _threadcounter$[ebp]
	mov	ecx, DWORD PTR _hThreads$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN5@startProgr

; 207  : 				CloseHandle(*hThreads[threadcounter]);

	mov	eax, DWORD PTR _threadcounter$[ebp]
	mov	ecx, DWORD PTR _hThreads$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	esi, esp
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@startProgr:

; 208  : 			free(hThreads[threadcounter]);

	mov	esi, esp
	mov	eax, DWORD PTR _threadcounter$[ebp]
	mov	ecx, DWORD PTR _hThreads$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 209  : 			free(database[threadcounter]);

	mov	esi, esp
	mov	eax, DWORD PTR _threadcounter$[ebp]
	mov	ecx, DWORD PTR _database$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 210  : 			deletePackage(packages[threadcounter]);

	mov	eax, DWORD PTR _threadcounter$[ebp]
	mov	ecx, DWORD PTR _packages$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_deletePackage
	add	esp, 4

; 211  : 		}

	jmp	$LN7@startProgr
$LN6@startProgr:

; 212  : 		
; 213  : 		if(counter>=LETTERS_NUMBER)

	cmp	DWORD PTR _counter$[ebp], 25		; 00000019H
	jl	SHORT $LN4@startProgr

; 214  : 			break;

	jmp	SHORT $LN17@startProgr

; 215  : 		else

	jmp	SHORT $LN3@startProgr
$LN4@startProgr:

; 216  : 			threadcounter=0;

	mov	DWORD PTR _threadcounter$[ebp], 0
$LN3@startProgr:

; 217  : 	}

	jmp	$LN18@startProgr
$LN17@startProgr:

; 218  : 	endTimefull=timeGetTime();

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _endTimefull, eax

; 219  : 	resultTime=(endTimefull-startTimefull);

	mov	eax, DWORD PTR _endTimefull
	sub	eax, DWORD PTR _startTimefull
	mov	DWORD PTR _resultTime, eax

; 220  : 	fwprintf(stdout,L"Execution time for %d units: %d\n", nLogicalProcessors, resultTime);

	mov	esi, esp
	mov	eax, DWORD PTR _resultTime
	push	eax
	mov	ecx, DWORD PTR _nLogicalProcessors
	push	ecx
	push	OFFSET ??_C@_1EC@ENMCEKOI@?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AA?$CF?$AAd?$AA?5?$AAu?$AAn?$AAi?$AAt?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?6@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	edx, 32					; 00000020H
	shl	edx, 0
	add	eax, edx
	push	eax
	call	DWORD PTR __imp__fwprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 221  : 	if(outputfilename!=NULL)

	cmp	DWORD PTR _outputfilename$[ebp], 0
	je	SHORT $LN2@startProgr

; 222  : 	output(results,2,fileptr2,outputfilename);

	mov	eax, DWORD PTR _outputfilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileptr2$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _results$[ebp]
	push	edx
	call	_output
	add	esp, 16					; 00000010H

; 223  : 	else 

	jmp	SHORT $LN1@startProgr
$LN2@startProgr:

; 224  : 	output(results,1,NULL,NULL);

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _results$[ebp]
	push	eax
	call	_output
	add	esp, 16					; 00000010H
$LN1@startProgr:

; 225  : 	clean(results);

	mov	eax, DWORD PTR _results$[ebp]
	push	eax
	call	_clean
	add	esp, 4

; 226  : 	free(packages);

	mov	esi, esp
	mov	eax, DWORD PTR _packages$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 227  : 	free(hThreads);

	mov	esi, esp
	mov	eax, DWORD PTR _hThreads$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 228  : 	free(database);

	mov	esi, esp
	mov	eax, DWORD PTR _database$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 229  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN26@startProgr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 344				; 00000158H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@startProgr:
	DD	2
	DD	$LN25@startProgr
$LN25@startProgr:
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN23@startProgr
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN24@startProgr
$LN24@startProgr:
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$LN23@startProgr:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_startProgramWithThreads ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _startProgram
_TEXT	SEGMENT
_filename$ = -72					; size = 4
_listlength$ = -60					; size = 4
_result$ = -48						; size = 4
_database$ = -36					; size = 4
_fileptr2$ = -24					; size = 4
_fileptr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_wordtofind$ = 8					; size = 4
_outputfilename$ = 12					; size = 4
_startProgram PROC					; COMDAT

; 130  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 131  : 	FILE * fileptr=NULL,*fileptr2=NULL;

	mov	DWORD PTR _fileptr$[ebp], 0
	mov	DWORD PTR _fileptr2$[ebp], 0

; 132  : 	Entry * database=NULL,*result=NULL;

	mov	DWORD PTR _database$[ebp], 0
	mov	DWORD PTR _result$[ebp], 0

; 133  : 	int listlength=0;

	mov	DWORD PTR _listlength$[ebp], 0

; 134  : 	char * filename=(char *)malloc(sizeof(char) * 100);

	mov	esi, esp
	push	100					; 00000064H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _filename$[ebp], eax

; 135  : 	strcpy(filename,STORE_START);

	push	OFFSET ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 136  : 	
; 137  : 	fwprintf(stdout,L"Tryb normalny.. \n");

	mov	esi, esp
	push	OFFSET ??_C@_1CE@MCHMMFAB@?$AAT?$AAr?$AAy?$AAb?$AA?5?$AAn?$AAo?$AAr?$AAm?$AAa?$AAl?$AAn?$AAy?$AA?4?$AA?4?$AA?5?$AA?6?$AA?$AA@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	add	eax, ecx
	push	eax
	call	DWORD PTR __imp__fwprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 138  : 	startTimefull=timeGetTime();

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _startTimefull, eax

; 139  : 
; 140  : 	for(;filename[5]<=90;filename[5]++)

	jmp	SHORT $LN6@startProgr
$LN5@startProgr:
	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _filename$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	add	dl, 1
	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _filename$[ebp]
	mov	BYTE PTR [ecx+eax], dl
$LN6@startProgr:
	mov	eax, 1
	imul	eax, 5
	mov	ecx, DWORD PTR _filename$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 90					; 0000005aH
	jg	$LN4@startProgr

; 141  : 	{
; 142  : 		fileptr=openFileAndGetNumberOfElements(filename,&listlength);

	lea	eax, DWORD PTR _listlength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_openFileAndGetNumberOfElements
	add	esp, 8
	mov	DWORD PTR _fileptr$[ebp], eax

; 143  : 		fwprintf(stdout,L"%s\n",chartowchar(filename));

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_chartowchar
	add	esp, 4
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_17MJEANDKP@?$AA?$CF?$AAs?$AA?6?$AA?$AA@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	add	eax, ecx
	push	eax
	call	DWORD PTR __imp__fwprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 144  : 		database=readEntriesFromFile(fileptr,wcslen(wordtofind));

	mov	esi, esp
	mov	eax, DWORD PTR _wordtofind$[ebp]
	push	eax
	call	DWORD PTR __imp__wcslen
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _fileptr$[ebp]
	push	ecx
	call	_readEntriesFromFile
	add	esp, 8
	mov	DWORD PTR _database$[ebp], eax

; 145  : 		if(database!=NULL)			

	cmp	DWORD PTR _database$[ebp], 0
	je	SHORT $LN3@startProgr

; 146  : 			result=addEntryToList(findAllEntries(wordtofind,database),result);

	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _database$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wordtofind$[ebp]
	push	edx
	call	_findAllEntries
	add	esp, 8
	push	eax
	call	_addEntryToList
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
$LN3@startProgr:

; 147  : 	}

	jmp	$LN5@startProgr
$LN4@startProgr:

; 148  : 	endTimefull=timeGetTime();

	mov	esi, esp
	call	DWORD PTR __imp__timeGetTime@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _endTimefull, eax

; 149  : 	resultTime=(endTimefull-startTimefull);

	mov	eax, DWORD PTR _endTimefull
	sub	eax, DWORD PTR _startTimefull
	mov	DWORD PTR _resultTime, eax

; 150  : 	fwprintf(stdout,L"Execution time for %d units: %d\n", nLogicalProcessors, resultTime);

	mov	esi, esp
	mov	eax, DWORD PTR _resultTime
	push	eax
	mov	ecx, DWORD PTR _nLogicalProcessors
	push	ecx
	push	OFFSET ??_C@_1EC@ENMCEKOI@?$AAE?$AAx?$AAe?$AAc?$AAu?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AA?$CF?$AAd?$AA?5?$AAu?$AAn?$AAi?$AAt?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?6@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	edx, 32					; 00000020H
	shl	edx, 0
	add	eax, edx
	push	eax
	call	DWORD PTR __imp__fwprintf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 151  : 	if(outputfilename!=NULL)

	cmp	DWORD PTR _outputfilename$[ebp], 0
	je	SHORT $LN2@startProgr

; 152  : 		output(result,2,fileptr2,outputfilename);

	mov	eax, DWORD PTR _outputfilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileptr2$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_output
	add	esp, 16					; 00000010H

; 153  : 	else 

	jmp	SHORT $LN1@startProgr
$LN2@startProgr:

; 154  : 		output(result,1,NULL,NULL);

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	call	_output
	add	esp, 16					; 00000010H
$LN1@startProgr:

; 155  : 	
; 156  : 	fwprintf(stdout,L"\n");

	mov	esi, esp
	push	OFFSET ??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	add	eax, ecx
	push	eax
	call	DWORD PTR __imp__fwprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 157  : 	clean(result);

	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	call	_clean
	add	esp, 4

; 158  : 
; 159  : 
; 160  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@startProgr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@startProgr:
	DD	1
	DD	$LN10@startProgr
$LN10@startProgr:
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN9@startProgr
$LN9@startProgr:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_startProgram ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _clean
_TEXT	SEGMENT
_tmp$ = -8						; size = 4
_database$ = 8						; size = 4
_clean	PROC						; COMDAT

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 114  : 	Entry * tmp=NULL;

	mov	DWORD PTR _tmp$[ebp], 0

; 115  : 
; 116  : 	if(database==NULL)

	cmp	DWORD PTR _database$[ebp], 0
	jne	SHORT $LN2@clean

; 117  : 		return;

	jmp	SHORT $LN4@clean
$LN2@clean:

; 118  : 	while(database!=NULL)

	cmp	DWORD PTR _database$[ebp], 0
	je	SHORT $LN4@clean

; 119  : 	{
; 120  : 		tmp=database;

	mov	eax, DWORD PTR _database$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 121  : 		database=database->next;

	mov	eax, DWORD PTR _database$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _database$[ebp], ecx

; 122  : 		free(tmp->word);

	mov	esi, esp
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 123  : 		tmp->word=NULL;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [eax], 0

; 124  : 		free(tmp);

	mov	esi, esp
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 125  : 		tmp=NULL;

	mov	DWORD PTR _tmp$[ebp], 0

; 126  : 	}

	jmp	SHORT $LN2@clean
$LN4@clean:

; 127  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_clean	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _outputDatabaseFile
_TEXT	SEGMENT
_tmpfile$ = -20						; size = 4
_tmp$ = -8						; size = 4
_database$ = 8						; size = 4
_fileptr$ = 12						; size = 4
_filename$ = 16						; size = 4
_outputDatabaseFile PROC				; COMDAT

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 90   : 	char * tmp=(char *) malloc(sizeof(char) * MAX_LENGTH_WORD);

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmp$[ebp], eax

; 91   : 	FILE * tmpfile=NULL;

	mov	DWORD PTR _tmpfile$[ebp], 0

; 92   : 
; 93   : 	
; 94   : 	if(database!=NULL)

	cmp	DWORD PTR _database$[ebp], 0
	je	$LN3@outputData

; 95   : 	{
; 96   : 		tmpfile=fopen(filename,"w");//zmiana freopen na fopen

	mov	esi, esp
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tmpfile$[ebp], eax

; 97   : 		fputs(_itoa(getNumberOfEntries(database),tmp,10),tmpfile);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpfile$[ebp]
	push	eax
	mov	edi, esp
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _database$[ebp]
	push	edx
	call	_getNumberOfEntries
	add	esp, 4
	push	eax
	call	DWORD PTR __imp___itoa
	add	esp, 12					; 0000000cH
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	DWORD PTR __imp__fputs
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 98   : 		fputs("\n",tmpfile);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpfile$[ebp]
	push	eax
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR __imp__fputs
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@outputData:

; 99   : 		while(database!=NULL)

	cmp	DWORD PTR _database$[ebp], 0
	je	SHORT $LN1@outputData

; 100  : 		{
; 101  : 			fputws(database->word,tmpfile);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpfile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _database$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__fputws
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 102  : 			fputws(L"\n",tmpfile);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpfile$[ebp]
	push	eax
	push	OFFSET ??_C@_13LBAGMAIH@?$AA?6?$AA?$AA@
	call	DWORD PTR __imp__fputws
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 103  : 			database=database->next;

	mov	eax, DWORD PTR _database$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _database$[ebp], ecx

; 104  : 		}

	jmp	SHORT $LN2@outputData
$LN1@outputData:

; 105  : 		fclose(tmpfile);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpfile$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@outputData:

; 106  : 		
; 107  : 	}
; 108  : 	free(tmp);

	mov	esi, esp
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 109  : 	
; 110  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_outputDatabaseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _outputDatabaseScreen
_TEXT	SEGMENT
_database$ = 8						; size = 4
_outputDatabaseScreen PROC				; COMDAT

; 75   : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 76   : 	if(database!=NULL)

	cmp	DWORD PTR _database$[ebp], 0
	je	SHORT $LN4@outputData
$LN3@outputData:

; 77   : 		while(database!=NULL)

	cmp	DWORD PTR _database$[ebp], 0
	je	SHORT $LN2@outputData

; 78   : 		{
; 79   : 			fputws(database->word,stdout);

	mov	esi, esp
	call	DWORD PTR __imp____iob_func
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	add	eax, ecx
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _database$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__fputws
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 80   : 			fputwc(L'\n',stdout);

	mov	esi, esp
	call	DWORD PTR __imp____iob_func
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, 32					; 00000020H
	shl	ecx, 0
	add	eax, ecx
	mov	esi, esp
	push	eax
	push	10					; 0000000aH
	call	DWORD PTR __imp__fputwc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 81   : 			database=database->next;

	mov	eax, DWORD PTR _database$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _database$[ebp], ecx

; 82   : 		}

	jmp	SHORT $LN3@outputData
$LN2@outputData:

; 83   : 	else

	jmp	SHORT $LN5@outputData
$LN4@outputData:

; 84   : 		puts("Brak wynikow!");

	mov	esi, esp
	push	OFFSET ??_C@_0O@FIENMJNC@Brak?5wynikow?$CB?$AA@
	call	DWORD PTR __imp__puts
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@outputData:

; 85   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_outputDatabaseScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _output
_TEXT	SEGMENT
_database$ = 8						; size = 4
_opt$ = 12						; size = 4
_fileptr$ = 16						; size = 4
_filename$ = 20						; size = 4
_output	PROC						; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 59   : 	if(opt!=0)

	cmp	DWORD PTR _opt$[ebp], 0
	je	SHORT $LN9@output

; 60   : 	{
; 61   : 		if((fileptr!=NULL) && (filename!=NULL))

	cmp	DWORD PTR _fileptr$[ebp], 0
	je	SHORT $LN7@output
	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN7@output

; 62   : 			outputDatabaseFile(database,fileptr,filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _database$[ebp]
	push	edx
	call	_outputDatabaseFile
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@output
$LN7@output:

; 63   : 		else if(opt==1)

	cmp	DWORD PTR _opt$[ebp], 1
	jne	SHORT $LN5@output

; 64   : 			outputDatabaseScreen(database);

	mov	eax, DWORD PTR _database$[ebp]
	push	eax
	call	_outputDatabaseScreen
	add	esp, 4
	jmp	SHORT $LN9@output
$LN5@output:

; 65   : 		else if(opt==2)

	cmp	DWORD PTR _opt$[ebp], 2
	jne	SHORT $LN9@output

; 66   : 		{
; 67   : 			if((fileptr==NULL) || (filename==NULL))

	cmp	DWORD PTR _fileptr$[ebp], 0
	je	SHORT $LN1@output
	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN2@output
$LN1@output:

; 68   : 				outputDatabaseFile(database,fileptr,filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _database$[ebp]
	push	edx
	call	_outputDatabaseFile
	add	esp, 12					; 0000000cH
$LN2@output:

; 69   : 			outputDatabaseScreen(database);

	mov	eax, DWORD PTR _database$[ebp]
	push	eax
	call	_outputDatabaseScreen
	add	esp, 4
$LN9@output:

; 70   : 		}
; 71   : 	}
; 72   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_output	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _findAllEntriesCounted
_TEXT	SEGMENT
_tmpcounter$ = -32					; size = 4
_tmpptr$ = -20						; size = 4
_results$ = -8						; size = 4
_wordtofind$ = 8					; size = 4
_database$ = 12						; size = 4
_counter$ = 16						; size = 4
_findAllEntriesCounted PROC				; COMDAT

; 38   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 39   : 	Entry * results=NULL, * tmpptr = NULL;

	mov	DWORD PTR _results$[ebp], 0
	mov	DWORD PTR _tmpptr$[ebp], 0

; 40   : 	int tmpcounter=0;

	mov	DWORD PTR _tmpcounter$[ebp], 0

; 41   : 
; 42   : 	if(database==NULL)

	cmp	DWORD PTR _database$[ebp], 0
	jne	SHORT $LN5@findAllEnt

; 43   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN7@findAllEnt
$LN5@findAllEnt:

; 44   : 	while(database!=NULL)

	cmp	DWORD PTR _database$[ebp], 0
	je	SHORT $LN4@findAllEnt

; 45   : 	{
; 46   : 		if(compare(database->word, wordtofind)!=NULL)

	mov	esi, esp
	mov	eax, DWORD PTR _wordtofind$[ebp]
	push	eax
	mov	ecx, DWORD PTR _database$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__compare
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN3@findAllEnt

; 47   : 			results=addEntryToList(newEntry(database->word,0),results);

	mov	eax, DWORD PTR _results$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _database$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_newEntry
	add	esp, 8
	push	eax
	call	_addEntryToList
	add	esp, 8
	mov	DWORD PTR _results$[ebp], eax
$LN3@findAllEnt:

; 48   : 		database=database->next;

	mov	eax, DWORD PTR _database$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _database$[ebp], ecx

; 49   : 		if(tmpcounter==counter)

	mov	eax, DWORD PTR _tmpcounter$[ebp]
	cmp	eax, DWORD PTR _counter$[ebp]
	jne	SHORT $LN2@findAllEnt

; 50   : 			break;

	jmp	SHORT $LN4@findAllEnt
	jmp	SHORT $LN1@findAllEnt
$LN2@findAllEnt:

; 51   : 		else tmpcounter++;

	mov	eax, DWORD PTR _tmpcounter$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmpcounter$[ebp], eax
$LN1@findAllEnt:

; 52   : 	}

	jmp	SHORT $LN5@findAllEnt
$LN4@findAllEnt:

; 53   : 	return results;

	mov	eax, DWORD PTR _results$[ebp]
$LN7@findAllEnt:

; 54   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_findAllEntriesCounted ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _findAllEntries
_TEXT	SEGMENT
_tmpptr2$ = -32						; size = 4
_tmpptr$ = -20						; size = 4
_results$ = -8						; size = 4
_wordtofind$ = 8					; size = 4
_database$ = 12						; size = 4
_findAllEntries PROC					; COMDAT

; 15   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 16   : 	Entry * results=NULL, * tmpptr=database, * tmpptr2=NULL;

	mov	DWORD PTR _results$[ebp], 0
	mov	eax, DWORD PTR _database$[ebp]
	mov	DWORD PTR _tmpptr$[ebp], eax
	mov	DWORD PTR _tmpptr2$[ebp], 0

; 17   : 
; 18   : 	if(database==NULL)

	cmp	DWORD PTR _database$[ebp], 0
	jne	SHORT $LN5@findAllEnt

; 19   : 		return NULL;

	xor	eax, eax
	jmp	$LN7@findAllEnt
$LN5@findAllEnt:

; 20   : 	while(database!=NULL)

	cmp	DWORD PTR _database$[ebp], 0
	je	SHORT $LN2@findAllEnt

; 21   : 	{
; 22   : 		
; 23   : 		if(	compare( database->word, wordtofind ) != NULL ) ///najwazniejsza linijka

	mov	esi, esp
	mov	eax, DWORD PTR _wordtofind$[ebp]
	push	eax
	mov	ecx, DWORD PTR _database$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__compare
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN3@findAllEnt

; 24   : 			results=addEntryToList(newEntry(database->word,0),results);

	mov	eax, DWORD PTR _results$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _database$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_newEntry
	add	esp, 8
	push	eax
	call	_addEntryToList
	add	esp, 8
	mov	DWORD PTR _results$[ebp], eax
$LN3@findAllEnt:

; 25   : 		free(database->word);

	mov	esi, esp
	mov	eax, DWORD PTR _database$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 26   : 		database=database->next;		

	mov	eax, DWORD PTR _database$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _database$[ebp], ecx

; 27   : 	}

	jmp	SHORT $LN5@findAllEnt
$LN2@findAllEnt:

; 28   : 	while(tmpptr!=NULL)

	cmp	DWORD PTR _tmpptr$[ebp], 0
	je	SHORT $LN1@findAllEnt

; 29   : 	{
; 30   : 		tmpptr2=tmpptr;		

	mov	eax, DWORD PTR _tmpptr$[ebp]
	mov	DWORD PTR _tmpptr2$[ebp], eax

; 31   : 		tmpptr=tmpptr->next;

	mov	eax, DWORD PTR _tmpptr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmpptr$[ebp], ecx

; 32   : 		free(tmpptr2);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpptr2$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 33   : 	}

	jmp	SHORT $LN2@findAllEnt
$LN1@findAllEnt:

; 34   : 	return results;

	mov	eax, DWORD PTR _results$[ebp]
$LN7@findAllEnt:

; 35   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_findAllEntries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _getSearchedWord
_TEXT	SEGMENT
_tab$ = 8						; size = 4
_getSearchedWord PROC					; COMDAT

; 9    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10   : 	return tab[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _tab$[ebp]
	mov	eax, DWORD PTR [ecx+eax]

; 11   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_getSearchedWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\hasla\program.c
;	COMDAT _GetNameOfFile
_TEXT	SEGMENT
_tab$ = 8						; size = 4
_GetNameOfFile PROC					; COMDAT

; 4    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5    : 	return tab[3];

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _tab$[ebp]
	mov	eax, DWORD PTR [ecx+eax]

; 6    : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GetNameOfFile ENDP
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Users\paind_000\Dysk Google\Grzesiek\Dokumenty\STUDIA\JA\Projekt\Hasla\DLLC\Entry.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_startTime
PUBLIC	_endTime
PUBLIC	_resultTime
PUBLIC	_endTimefull
PUBLIC	_startTimefull
PUBLIC	_CPUInfo
PUBLIC	_bSSE41Extensions
PUBLIC	_bSSE42Extensions
PUBLIC	_nLogicalProcessors
PUBLIC	_nFeatureInfo
PUBLIC	_bMultithreading
_DATA	SEGMENT
COMM	___@@_PchSym_@00@UfhvihUkzrmwPAAAUwbhpLtlltovUtiavhrvpUwlpfnvmgbUhgfwrzUqzUkilqvpgUszhozUwooxUwvyftUhgwzucOlyq@436CB9B52E1C589D:DWORD
_DATA	ENDS
_BSS	SEGMENT
_startTime DD	01H DUP (?)
_endTime DD	01H DUP (?)
_resultTime DD	01H DUP (?)
_endTimefull DD	01H DUP (?)
_startTimefull DD 01H DUP (?)
_bSSE41Extensions DB 01H DUP (?)
	ALIGN	4

_bSSE42Extensions DB 01H DUP (?)
	ALIGN	4

_nLogicalProcessors DD 01H DUP (?)
_nFeatureInfo DD 01H DUP (?)
_bMultithreading DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_CPUInfo DD	0ffffffffH
	ORG $+12
_DATA	ENDS
PUBLIC	_newEntry
PUBLIC	_addEntryToList
PUBLIC	_readEntriesFromFile
PUBLIC	_writeEntriesToFileOrScreen
PUBLIC	_getNumberOfEntries
PUBLIC	_setPackage
PUBLIC	_deletePackage
PUBLIC	??_C@_0CG@MPHPHLCI@Nie?5udalo?5sie?5wczytac?5danych?5z?5p@ ; `string'
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__feof:PROC
EXTRN	__imp__fgets:PROC
EXTRN	__imp__fputs:PROC
EXTRN	__imp__printf:PROC
EXTRN	__imp__puts:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CG@MPHPHLCI@Nie?5udalo?5sie?5wczytac?5danych?5z?5p@
CONST	SEGMENT
??_C@_0CG@MPHPHLCI@Nie?5udalo?5sie?5wczytac?5danych?5z?5p@ DB 'Nie udalo '
	DB	'sie wczytac danych z pliku', 0aH, 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\entry.c
;	COMDAT _deletePackage
_TEXT	SEGMENT
_pack$ = 8						; size = 4
_deletePackage PROC					; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 107  : 	free(pack->word);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _pack$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	51		 push	 ecx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0002c	83 c4 04	 add	 esp, 4
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 108  : 	free(pack);

  00036	8b f4		 mov	 esi, esp
  00038	8b 45 08	 mov	 eax, DWORD PTR _pack$[ebp]
  0003b	50		 push	 eax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00042	83 c4 04	 add	 esp, 4
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 109  : 	return NULL;

  0004c	33 c0		 xor	 eax, eax

; 110  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_deletePackage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\entry.c
;	COMDAT _setPackage
_TEXT	SEGMENT
_package$ = -8						; size = 4
_word$ = 8						; size = 4
_database$ = 12						; size = 4
_results$ = 16						; size = 4
_fileptr$ = 20						; size = 4
_counter$ = 24						; size = 4
_setPackage PROC					; COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 94   : 	Package * package=(Package *) malloc (sizeof(Package));

  0001e	8b f4		 mov	 esi, esp
  00020	6a 14		 push	 20			; 00000014H
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00028	83 c4 04	 add	 esp, 4
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	89 45 f8	 mov	 DWORD PTR _package$[ebp], eax

; 95   : 
; 96   : 	package->word=(char *) calloc(strlen(word)+1,sizeof(char));

  00035	8b f4		 mov	 esi, esp
  00037	6a 01		 push	 1
  00039	8b 45 08	 mov	 eax, DWORD PTR _word$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _strlen
  00042	83 c4 04	 add	 esp, 4
  00045	83 c0 01	 add	 eax, 1
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0004f	83 c4 08	 add	 esp, 8
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _package$[ebp]
  0005c	89 01		 mov	 DWORD PTR [ecx], eax

; 97   : 	strcpy(package->word,word);

  0005e	8b 45 08	 mov	 eax, DWORD PTR _word$[ebp]
  00061	50		 push	 eax
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _package$[ebp]
  00065	8b 11		 mov	 edx, DWORD PTR [ecx]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 _strcpy
  0006d	83 c4 08	 add	 esp, 8

; 98   : 	package->database=database;

  00070	8b 45 f8	 mov	 eax, DWORD PTR _package$[ebp]
  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _database$[ebp]
  00076	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 99   : 	package->results=results;

  00079	8b 45 f8	 mov	 eax, DWORD PTR _package$[ebp]
  0007c	8b 4d 10	 mov	 ecx, DWORD PTR _results$[ebp]
  0007f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 100  : 	package->counter=counter;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _package$[ebp]
  00085	8b 4d 18	 mov	 ecx, DWORD PTR _counter$[ebp]
  00088	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 101  : 	package->fileptr=fileptr;

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _package$[ebp]
  0008e	8b 4d 14	 mov	 ecx, DWORD PTR _fileptr$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 102  : 	return package;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _package$[ebp]

; 103  : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_setPackage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\entry.c
;	COMDAT _getNumberOfEntries
_TEXT	SEGMENT
_i$ = -8						; size = 4
_database$ = 8						; size = 4
_getNumberOfEntries PROC				; COMDAT

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 79   : 	int i=0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 80   : 
; 81   : 	if(database!=NULL)

  00025	83 7d 08 00	 cmp	 DWORD PTR _database$[ebp], 0
  00029	74 1a		 je	 SHORT $LN3@getNumberO
$LN2@getNumberO:

; 82   : 	{
; 83   : 		while(database!=NULL)

  0002b	83 7d 08 00	 cmp	 DWORD PTR _database$[ebp], 0
  0002f	74 14		 je	 SHORT $LN3@getNumberO

; 84   : 		{
; 85   : 			i++;

  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 86   : 			database=database->next;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _database$[ebp]
  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	89 4d 08	 mov	 DWORD PTR _database$[ebp], ecx

; 87   : 		}

  00043	eb e6		 jmp	 SHORT $LN2@getNumberO
$LN3@getNumberO:

; 88   : 	}
; 89   : 	return i;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]

; 90   : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_getNumberOfEntries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\entry.c
;	COMDAT _writeEntriesToFileOrScreen
_TEXT	SEGMENT
_fileptr$ = 8						; size = 4
_database$ = 12						; size = 4
_opt$ = 16						; size = 1
_writeEntriesToFileOrScreen PROC			; COMDAT

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 64   : 	if(database!=NULL)

  0001e	83 7d 0c 00	 cmp	 DWORD PTR _database$[ebp], 0
  00022	74 4f		 je	 SHORT $LN6@writeEntri
$LN4@writeEntri:

; 65   : 	{
; 66   : 		while(database!=NULL)

  00024	83 7d 0c 00	 cmp	 DWORD PTR _database$[ebp], 0
  00028	74 49		 je	 SHORT $LN6@writeEntri

; 67   : 		{
; 68   : 			if(opt==0)

  0002a	0f b6 45 10	 movzx	 eax, BYTE PTR _opt$[ebp]
  0002e	85 c0		 test	 eax, eax
  00030	75 1e		 jne	 SHORT $LN2@writeEntri

; 69   : 				fputs(database->word,fileptr);

  00032	8b f4		 mov	 esi, esp
  00034	8b 45 08	 mov	 eax, DWORD PTR _fileptr$[ebp]
  00037	50		 push	 eax
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _database$[ebp]
  0003b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003d	52		 push	 edx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputs
  00044	83 c4 08	 add	 esp, 8
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 70   : 			else

  0004e	eb 18		 jmp	 SHORT $LN1@writeEntri
$LN2@writeEntri:

; 71   : 				puts(database->word);

  00050	8b f4		 mov	 esi, esp
  00052	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	51		 push	 ecx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__puts
  0005e	83 c4 04	 add	 esp, 4
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@writeEntri:

; 72   : 			database=database->next;

  00068	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
  0006b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006e	89 4d 0c	 mov	 DWORD PTR _database$[ebp], ecx

; 73   : 		}		

  00071	eb b1		 jmp	 SHORT $LN4@writeEntri
$LN6@writeEntri:

; 74   : 	}
; 75   : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_writeEntriesToFileOrScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\entry.c
;	COMDAT _readEntriesFromFile
_TEXT	SEGMENT
_tmp$ = -44						; size = 4
_tmppointer$ = -32					; size = 4
_datatmp$ = -20						; size = 4
_database$ = -8						; size = 4
_fileptr$ = 8						; size = 4
_readEntriesFromFile PROC				; COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 38   : 	Entry * database=NULL,*datatmp=database, * tmppointer=NULL;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _database$[ebp], 0
  00025	8b 45 f8	 mov	 eax, DWORD PTR _database$[ebp]
  00028	89 45 ec	 mov	 DWORD PTR _datatmp$[ebp], eax
  0002b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _tmppointer$[ebp], 0

; 39   : 	char * tmp=NULL;

  00032	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _tmp$[ebp], 0

; 40   : 	if(fileptr!=NULL)

  00039	83 7d 08 00	 cmp	 DWORD PTR _fileptr$[ebp], 0
  0003d	0f 84 b3 00 00
	00		 je	 $LN7@readEntrie
$LN6@readEntrie:

; 41   : 	{
; 42   : 		while(!feof(fileptr))

  00043	8b f4		 mov	 esi, esp
  00045	8b 45 08	 mov	 eax, DWORD PTR _fileptr$[ebp]
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__feof
  0004f	83 c4 04	 add	 esp, 4
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	85 c0		 test	 eax, eax
  0005b	0f 85 93 00 00
	00		 jne	 $LN5@readEntrie

; 43   : 		{			
; 44   : 			tmp=(char *)malloc(sizeof(char) * MAX_LENGTH_WORD);

  00061	8b f4		 mov	 esi, esp
  00063	6a 20		 push	 32			; 00000020H
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0006b	83 c4 04	 add	 esp, 4
  0006e	3b f4		 cmp	 esi, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	89 45 d4	 mov	 DWORD PTR _tmp$[ebp], eax

; 45   : 			datatmp=newEntry(fgets(tmp,MAX_LENGTH_WORD,fileptr),1);

  00078	6a 01		 push	 1
  0007a	8b f4		 mov	 esi, esp
  0007c	8b 45 08	 mov	 eax, DWORD PTR _fileptr$[ebp]
  0007f	50		 push	 eax
  00080	6a 20		 push	 32			; 00000020H
  00082	8b 4d d4	 mov	 ecx, DWORD PTR _tmp$[ebp]
  00085	51		 push	 ecx
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgets
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	3b f4		 cmp	 esi, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _newEntry
  0009c	83 c4 08	 add	 esp, 8
  0009f	89 45 ec	 mov	 DWORD PTR _datatmp$[ebp], eax

; 46   : 			if(tmppointer!=NULL)

  000a2	83 7d e0 00	 cmp	 DWORD PTR _tmppointer$[ebp], 0
  000a6	74 09		 je	 SHORT $LN4@readEntrie

; 47   : 				tmppointer->next=datatmp;

  000a8	8b 45 e0	 mov	 eax, DWORD PTR _tmppointer$[ebp]
  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _datatmp$[ebp]
  000ae	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN4@readEntrie:

; 48   : 			tmppointer=datatmp;

  000b1	8b 45 ec	 mov	 eax, DWORD PTR _datatmp$[ebp]
  000b4	89 45 e0	 mov	 DWORD PTR _tmppointer$[ebp], eax

; 49   : 			if(database==NULL)

  000b7	83 7d f8 00	 cmp	 DWORD PTR _database$[ebp], 0
  000bb	75 06		 jne	 SHORT $LN3@readEntrie

; 50   : 				database=datatmp;

  000bd	8b 45 ec	 mov	 eax, DWORD PTR _datatmp$[ebp]
  000c0	89 45 f8	 mov	 DWORD PTR _database$[ebp], eax
$LN3@readEntrie:

; 51   : 			free(tmp);

  000c3	8b f4		 mov	 esi, esp
  000c5	8b 45 d4	 mov	 eax, DWORD PTR _tmp$[ebp]
  000c8	50		 push	 eax
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000cf	83 c4 04	 add	 esp, 4
  000d2	3b f4		 cmp	 esi, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 52   : 			tmp=NULL;

  000d9	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _tmp$[ebp], 0

; 53   : 			if (datatmp!=NULL)

  000e0	83 7d ec 00	 cmp	 DWORD PTR _datatmp$[ebp], 0
  000e4	74 09		 je	 SHORT $LN2@readEntrie

; 54   : 				datatmp=datatmp->next;

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _datatmp$[ebp]
  000e9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ec	89 4d ec	 mov	 DWORD PTR _datatmp$[ebp], ecx
$LN2@readEntrie:

; 55   : 		}

  000ef	e9 4f ff ff ff	 jmp	 $LN6@readEntrie
$LN5@readEntrie:

; 56   : 	}
; 57   : 	else

  000f4	eb 17		 jmp	 SHORT $LN1@readEntrie
$LN7@readEntrie:

; 58   : 		printf("Nie udalo sie wczytac danych z pliku\n");

  000f6	8b f4		 mov	 esi, esp
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@MPHPHLCI@Nie?5udalo?5sie?5wczytac?5danych?5z?5p@
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00103	83 c4 04	 add	 esp, 4
  00106	3b f4		 cmp	 esi, esp
  00108	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@readEntrie:

; 59   : 	return database;

  0010d	8b 45 f8	 mov	 eax, DWORD PTR _database$[ebp]

; 60   : }

  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00119	3b ec		 cmp	 ebp, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
_readEntriesFromFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\entry.c
;	COMDAT _addEntryToList
_TEXT	SEGMENT
_tmpbase$ = -8						; size = 4
_element$ = 8						; size = 4
_database$ = 12						; size = 4
_addEntryToList PROC					; COMDAT

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 24   : 	Entry * tmpbase=database;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _tmpbase$[ebp], eax

; 25   : 	if(database==NULL)

  00024	83 7d 0c 00	 cmp	 DWORD PTR _database$[ebp], 0
  00028	75 0d		 jne	 SHORT $LN2@addEntryTo

; 26   : 	{
; 27   : 	    database=element;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _element$[ebp]
  0002d	89 45 0c	 mov	 DWORD PTR _database$[ebp], eax

; 28   : 		return database;

  00030	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
  00033	eb 22		 jmp	 SHORT $LN5@addEntryTo

; 29   : 	}
; 30   : 	else

  00035	eb 14		 jmp	 SHORT $LN3@addEntryTo
$LN2@addEntryTo:

; 31   : 		while(tmpbase->next!=NULL)

  00037	8b 45 f8	 mov	 eax, DWORD PTR _tmpbase$[ebp]
  0003a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0003e	74 0b		 je	 SHORT $LN3@addEntryTo

; 32   : 			tmpbase=tmpbase->next;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _tmpbase$[ebp]
  00043	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00046	89 4d f8	 mov	 DWORD PTR _tmpbase$[ebp], ecx
  00049	eb ec		 jmp	 SHORT $LN2@addEntryTo
$LN3@addEntryTo:

; 33   : 	tmpbase->next=element;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _tmpbase$[ebp]
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _element$[ebp]
  00051	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 34   : 	return database;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
$LN5@addEntryTo:

; 35   : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_addEntryToList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\entry.c
;	COMDAT _newEntry
_TEXT	SEGMENT
_tmp$ = -8						; size = 4
_name$ = 8						; size = 4
_opt$ = 12						; size = 4
_newEntry PROC						; COMDAT

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 6    : 	Entry * tmp=NULL;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tmp$[ebp], 0

; 7    : 	if(name!=NULL)

  00025	83 7d 08 00	 cmp	 DWORD PTR _name$[ebp], 0
  00029	0f 84 a4 00 00
	00		 je	 $LN3@newEntry

; 8    : 	{
; 9    : 		tmp=(Entry *)malloc(sizeof(Entry));

  0002f	8b f4		 mov	 esi, esp
  00031	6a 08		 push	 8
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00039	83 c4 04	 add	 esp, 4
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	89 45 f8	 mov	 DWORD PTR _tmp$[ebp], eax

; 10   : 		tmp->word=(char *) malloc((strlen(name)+1) * sizeof(char));

  00046	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _strlen
  0004f	83 c4 04	 add	 esp, 4
  00052	83 c0 01	 add	 eax, 1
  00055	8b f4		 mov	 esi, esp
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0005e	83 c4 04	 add	 esp, 4
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  0006b	89 01		 mov	 DWORD PTR [ecx], eax

; 11   : 		strncpy(tmp->word,name,strlen(name));

  0006d	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _strlen
  00076	83 c4 04	 add	 esp, 4
  00079	8b f4		 mov	 esi, esp
  0007b	50		 push	 eax
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  0007f	51		 push	 ecx
  00080	8b 55 f8	 mov	 edx, DWORD PTR _tmp$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	3b f4		 cmp	 esi, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 12   : 		if(opt==1)

  00096	83 7d 0c 01	 cmp	 DWORD PTR _opt$[ebp], 1
  0009a	75 18		 jne	 SHORT $LN2@newEntry

; 13   : 			tmp->word[strlen(name)-1]=0;

  0009c	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _strlen
  000a5	83 c4 04	 add	 esp, 4
  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	c6 44 02 ff 00	 mov	 BYTE PTR [edx+eax-1], 0

; 14   : 		else

  000b2	eb 15		 jmp	 SHORT $LN1@newEntry
$LN2@newEntry:

; 15   : 			tmp->word[strlen(name)]=0;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _strlen
  000bd	83 c4 04	 add	 esp, 4
  000c0	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
$LN1@newEntry:

; 16   : 			
; 17   : 		tmp->next=NULL;

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _tmp$[ebp]
  000cc	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN3@newEntry:

; 18   : 	}
; 19   : 	return tmp;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _tmp$[ebp]

; 20   : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000df	3b ec		 cmp	 ebp, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_newEntry ENDP
_TEXT	ENDS
END

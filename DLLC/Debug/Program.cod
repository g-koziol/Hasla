; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Users\paind_000\Dysk Google\Grzesiek\Dokumenty\STUDIA\JA\Projekt\Hasla\DLLC\Program.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_startTime
PUBLIC	_endTime
PUBLIC	_resultTime
PUBLIC	_endTimefull
PUBLIC	_startTimefull
PUBLIC	_CPUInfo
PUBLIC	_bSSE41Extensions
PUBLIC	_bSSE42Extensions
PUBLIC	_nLogicalProcessors
PUBLIC	_nFeatureInfo
PUBLIC	_bMultithreading
_DATA	SEGMENT
COMM	___@@_PchSym_@00@UfhvihUkzrmwPAAAUwbhpLtlltovUtiavhrvpUwlpfnvmgbUhgfwrzUqzUkilqvpgUszhozUwooxUwvyftUhgwzucOlyq@436CB9B52E1C589D:DWORD
_DATA	ENDS
_BSS	SEGMENT
_startTime DD	01H DUP (?)
_endTime DD	01H DUP (?)
_resultTime DD	01H DUP (?)
_endTimefull DD	01H DUP (?)
_startTimefull DD 01H DUP (?)
_bSSE41Extensions DB 01H DUP (?)
	ALIGN	4

_bSSE42Extensions DB 01H DUP (?)
	ALIGN	4

_nLogicalProcessors DD 01H DUP (?)
_nFeatureInfo DD 01H DUP (?)
_bMultithreading DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_CPUInfo DD	0ffffffffH
	ORG $+12
_DATA	ENDS
PUBLIC	_GetNameOfFile
PUBLIC	_getSearchedWord
PUBLIC	_findAllEntries
PUBLIC	_findAllEntriesCounted
PUBLIC	_output
PUBLIC	_outputDatabaseScreen
PUBLIC	_outputDatabaseFile
PUBLIC	_clean
PUBLIC	_startProgram
PUBLIC	_startProgramWithThreads
PUBLIC	_useSpeedToFindOneFile
PUBLIC	_setPointers
PUBLIC	_searchThreadCounted@4
PUBLIC	_searchThreadUncounted@4
PUBLIC	_readNumberOfLogicalUnits
PUBLIC	??_C@_0O@FIENMJNC@Brak?5wynikow?$CB?$AA@	; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0L@FADCIPKF@data?2A?4txt?$AA@		; `string'
PUBLIC	??_C@_0BC@HJOJEJNA@Tryb?5normalny?4?4?5?6?$AA@	; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0CB@JHNJPOB@Execution?5time?5for?5?$CFd?5units?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BB@JMANOGFA@Tryb?5szybki?4?4?4?5?6?$AA@	; `string'
EXTRN	__imp__strstr:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fputs:PROC
EXTRN	__imp__getchar:PROC
EXTRN	__imp__printf:PROC
EXTRN	__imp__puts:PROC
EXTRN	__imp___itoa:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp___beginthreadex:PROC
EXTRN	__imp___endthreadex:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	_newEntry:PROC
EXTRN	_addEntryToList:PROC
EXTRN	_readEntriesFromFile:PROC
EXTRN	_getNumberOfEntries:PROC
EXTRN	_setPackage:PROC
EXTRN	_deletePackage:PROC
EXTRN	_openFileAndGetNumberOfElements:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BB@JMANOGFA@Tryb?5szybki?4?4?4?5?6?$AA@
CONST	SEGMENT
??_C@_0BB@JMANOGFA@Tryb?5szybki?4?4?4?5?6?$AA@ DB 'Tryb szybki... ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JHNJPOB@Execution?5time?5for?5?$CFd?5units?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0CB@JHNJPOB@Execution?5time?5for?5?$CFd?5units?3?5?$CFd?6@ DB 'Exec'
	DB	'ution time for %d units: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HJOJEJNA@Tryb?5normalny?4?4?5?6?$AA@
CONST	SEGMENT
??_C@_0BC@HJOJEJNA@Tryb?5normalny?4?4?5?6?$AA@ DB 'Tryb normalny.. ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@
CONST	SEGMENT
??_C@_0L@FADCIPKF@data?2A?4txt?$AA@ DB 'data\A.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FIENMJNC@Brak?5wynikow?$CB?$AA@
CONST	SEGMENT
??_C@_0O@FIENMJNC@Brak?5wynikow?$CB?$AA@ DB 'Brak wynikow!', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _readNumberOfLogicalUnits
_TEXT	SEGMENT
_readNumberOfLogicalUnits PROC				; COMDAT

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 319  : 	__cpuid(CPUInfo,1);

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	33 c9		 xor	 ecx, ecx
  00025	0f a2		 cpuid
  00027	be 00 00 00 00	 mov	 esi, OFFSET _CPUInfo
  0002c	89 06		 mov	 DWORD PTR [esi], eax
  0002e	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00031	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00034	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 320  : 	return ((CPUInfo[1] >> 16) & 0xff)-1;

  00037	b8 04 00 00 00	 mov	 eax, 4
  0003c	c1 e0 00	 shl	 eax, 0
  0003f	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _CPUInfo[eax]
  00045	c1 f8 10	 sar	 eax, 16			; 00000010H
  00048	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004d	83 e8 01	 sub	 eax, 1

; 321  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_readNumberOfLogicalUnits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _searchThreadUncounted@4
_TEXT	SEGMENT
_database$ = -32					; size = 4
_results$ = -20						; size = 4
_pack$ = -8						; size = 4
_arg$ = 8						; size = 4
_searchThreadUncounted@4 PROC				; COMDAT

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 304  : 	Package * pack=(Package *)arg;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _arg$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _pack$[ebp], eax

; 305  : 	Entry * results=NULL, * database=NULL;	

  00024	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _results$[ebp], 0
  0002b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _database$[ebp], 0

; 306  : 
; 307  : 	database=readEntriesFromFile(pack->fileptr);

  00032	8b 45 f8	 mov	 eax, DWORD PTR _pack$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _readEntriesFromFile
  0003e	83 c4 04	 add	 esp, 4
  00041	89 45 e0	 mov	 DWORD PTR _database$[ebp], eax

; 308  : 	results=findAllEntries(pack->word,database);

  00044	8b 45 e0	 mov	 eax, DWORD PTR _database$[ebp]
  00047	50		 push	 eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _pack$[ebp]
  0004b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _findAllEntries
  00053	83 c4 08	 add	 esp, 8
  00056	89 45 ec	 mov	 DWORD PTR _results$[ebp], eax

; 309  : 	pack->results=results;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _pack$[ebp]
  0005c	8b 4d ec	 mov	 ecx, DWORD PTR _results$[ebp]
  0005f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 310  : 	fclose(pack->fileptr);

  00062	8b f4		 mov	 esi, esp
  00064	8b 45 f8	 mov	 eax, DWORD PTR _pack$[ebp]
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	51		 push	 ecx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00071	83 c4 04	 add	 esp, 4
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 311  : 	pack->fileptr=NULL;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR _pack$[ebp]
  0007e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 312  : 	_endthreadex(0);

  00085	8b f4		 mov	 esi, esp
  00087	6a 00		 push	 0
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___endthreadex
  0008f	83 c4 04	 add	 esp, 4
  00092	3b f4		 cmp	 esi, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 313  : 
; 314  : 	return 0;

  00099	33 c0		 xor	 eax, eax

; 315  : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
_searchThreadUncounted@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _searchThreadCounted@4
_TEXT	SEGMENT
_results$ = -20						; size = 4
_pack$ = -8						; size = 4
_arg$ = 8						; size = 4
_searchThreadCounted@4 PROC				; COMDAT

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 292  : 	Package * pack=(Package *)arg;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _arg$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _pack$[ebp], eax

; 293  : 	Entry * results=NULL;	

  00024	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _results$[ebp], 0

; 294  : 
; 295  : 	results=findAllEntriesCounted(pack->word,pack->database,pack->counter);

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _pack$[ebp]
  0002e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00031	51		 push	 ecx
  00032	8b 55 f8	 mov	 edx, DWORD PTR _pack$[ebp]
  00035	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00038	50		 push	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _pack$[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _findAllEntriesCounted
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	89 45 ec	 mov	 DWORD PTR _results$[ebp], eax

; 296  : 	pack->results=results;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _pack$[ebp]
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _results$[ebp]
  00050	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 297  : 	_endthreadex(0);

  00053	8b f4		 mov	 esi, esp
  00055	6a 00		 push	 0
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___endthreadex
  0005d	83 c4 04	 add	 esp, 4
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 298  : 
; 299  : 	return 0;

  00067	33 c0		 xor	 eax, eax

; 300  : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
_searchThreadCounted@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _setPointers
_TEXT	SEGMENT
_counter$ = -44						; size = 4
_i$ = -32						; size = 4
_tmp$ = -20						; size = 4
_tab$ = -8						; size = 4
_database$ = 8						; size = 4
_indicators$ = 12					; size = 4
_setPointers PROC					; COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 273  : 	Entry ** tab=(Entry **) calloc(nLogicalProcessors,sizeof(Entry *));

  0001e	8b f4		 mov	 esi, esp
  00020	6a 04		 push	 4
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _nLogicalProcessors
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0002e	83 c4 08	 add	 esp, 8
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	89 45 f8	 mov	 DWORD PTR _tab$[ebp], eax

; 274  : 	Entry * tmp=database;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _database$[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR _tmp$[ebp], eax

; 275  : 	int i=0, counter=1;

  00041	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00048	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _counter$[ebp], 1

; 276  : 
; 277  : 	for(;i<nLogicalProcessors;i++)

  0004f	eb 09		 jmp	 SHORT $LN5@setPointer
$LN4@setPointer:
  00051	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00054	83 c0 01	 add	 eax, 1
  00057	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN5@setPointer:
  0005a	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0005d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLogicalProcessors
  00063	7d 32		 jge	 SHORT $LN3@setPointer
$LN2@setPointer:

; 278  : 	{
; 279  : 		while(counter<*(indicators[i]))

  00065	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _indicators$[ebp]
  0006b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0006e	8b 45 d4	 mov	 eax, DWORD PTR _counter$[ebp]
  00071	3b 02		 cmp	 eax, DWORD PTR [edx]
  00073	7d 14		 jge	 SHORT $LN1@setPointer

; 280  : 		{
; 281  : 			tmp=tmp->next;

  00075	8b 45 ec	 mov	 eax, DWORD PTR _tmp$[ebp]
  00078	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007b	89 4d ec	 mov	 DWORD PTR _tmp$[ebp], ecx

; 282  : 			counter++;

  0007e	8b 45 d4	 mov	 eax, DWORD PTR _counter$[ebp]
  00081	83 c0 01	 add	 eax, 1
  00084	89 45 d4	 mov	 DWORD PTR _counter$[ebp], eax

; 283  : 		}

  00087	eb dc		 jmp	 SHORT $LN2@setPointer
$LN1@setPointer:

; 284  : 		tab[i]=tmp;

  00089	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _tab$[ebp]
  0008f	8b 55 ec	 mov	 edx, DWORD PTR _tmp$[ebp]
  00092	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 285  : 	}

  00095	eb ba		 jmp	 SHORT $LN4@setPointer
$LN3@setPointer:

; 286  : 
; 287  : 	return tab;

  00097	8b 45 f8	 mov	 eax, DWORD PTR _tab$[ebp]

; 288  : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_setPointers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _useSpeedToFindOneFile
_TEXT	SEGMENT
_counter2$ = -128					; size = 4
_counter$ = -116					; size = 4
_diff$ = -104						; size = 4
_leftentries$ = -92					; size = 4
_i$ = -80						; size = 4
_entryptr$ = -68					; size = 4
_results$ = -56						; size = 4
_hThreads$ = -44					; size = 4
_packages$ = -32					; size = 4
_threadid$ = -20					; size = 4
_tab$ = -8						; size = 4
_word$ = 8						; size = 4
_database$ = 12						; size = 4
_useSpeedToFindOneFile PROC				; COMDAT

; 227  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd bc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-324]
  00012	b9 51 00 00 00	 mov	 ecx, 81			; 00000051H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 228  : 	int ** tab=(int **)calloc(nLogicalProcessors,sizeof(int *));

  0001e	8b f4		 mov	 esi, esp
  00020	6a 04		 push	 4
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _nLogicalProcessors
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0002e	83 c4 08	 add	 esp, 8
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	89 45 f8	 mov	 DWORD PTR _tab$[ebp], eax

; 229  : 	unsigned int threadid=0;

  0003b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _threadid$[ebp], 0

; 230  : 	Package ** packages=(Package **)calloc(nLogicalProcessors,sizeof(Package *)); 

  00042	8b f4		 mov	 esi, esp
  00044	6a 04		 push	 4
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _nLogicalProcessors
  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00052	83 c4 08	 add	 esp, 8
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	89 45 e0	 mov	 DWORD PTR _packages$[ebp], eax

; 231  : 	HANDLE ** hThreads=(HANDLE **)calloc(nLogicalProcessors,sizeof(HANDLE *));

  0005f	8b f4		 mov	 esi, esp
  00061	6a 04		 push	 4
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _nLogicalProcessors
  00068	50		 push	 eax
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0006f	83 c4 08	 add	 esp, 8
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	89 45 d4	 mov	 DWORD PTR _hThreads$[ebp], eax

; 232  : 	//HANDLE ** hEvents=(HANDLE **)calloc(nLogicalProcessors,sizeof(HANDLE *));
; 233  : 	Entry * results=NULL, ** entryptr ;

  0007c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _results$[ebp], 0

; 234  : 	int i=0, leftentries=getNumberOfEntries(database), diff=leftentries / nLogicalProcessors, counter=0, counter2=0;	

  00083	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0008a	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _getNumberOfEntries
  00093	83 c4 04	 add	 esp, 4
  00096	89 45 a4	 mov	 DWORD PTR _leftentries$[ebp], eax
  00099	8b 45 a4	 mov	 eax, DWORD PTR _leftentries$[ebp]
  0009c	99		 cdq
  0009d	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _nLogicalProcessors
  000a3	89 45 98	 mov	 DWORD PTR _diff$[ebp], eax
  000a6	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _counter$[ebp], 0
  000ad	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _counter2$[ebp], 0

; 235  : 
; 236  : 	for(;i<nLogicalProcessors;i++)

  000b4	eb 09		 jmp	 SHORT $LN12@useSpeedTo
$LN11@useSpeedTo:
  000b6	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  000b9	83 c0 01	 add	 eax, 1
  000bc	89 45 b0	 mov	 DWORD PTR _i$[ebp], eax
$LN12@useSpeedTo:
  000bf	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  000c2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLogicalProcessors
  000c8	7d 3e		 jge	 SHORT $LN10@useSpeedTo

; 237  : 	{
; 238  : 		tab[i]=(int *)malloc(sizeof(int));

  000ca	8b f4		 mov	 esi, esp
  000cc	6a 04		 push	 4
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000d4	83 c4 04	 add	 esp, 4
  000d7	3b f4		 cmp	 esi, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000de	8b 4d b0	 mov	 ecx, DWORD PTR _i$[ebp]
  000e1	8b 55 f8	 mov	 edx, DWORD PTR _tab$[ebp]
  000e4	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 239  : 		*(tab[i])=counter;

  000e7	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _tab$[ebp]
  000ed	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000f0	8b 45 8c	 mov	 eax, DWORD PTR _counter$[ebp]
  000f3	89 02		 mov	 DWORD PTR [edx], eax

; 240  : 		counter=counter+diff;

  000f5	8b 45 8c	 mov	 eax, DWORD PTR _counter$[ebp]
  000f8	03 45 98	 add	 eax, DWORD PTR _diff$[ebp]
  000fb	89 45 8c	 mov	 DWORD PTR _counter$[ebp], eax

; 241  : 		leftentries=-diff;;

  000fe	8b 45 98	 mov	 eax, DWORD PTR _diff$[ebp]
  00101	f7 d8		 neg	 eax
  00103	89 45 a4	 mov	 DWORD PTR _leftentries$[ebp], eax

; 242  : 	}

  00106	eb ae		 jmp	 SHORT $LN11@useSpeedTo
$LN10@useSpeedTo:

; 243  : 
; 244  : 	entryptr=setPointers(database,tab);

  00108	8b 45 f8	 mov	 eax, DWORD PTR _tab$[ebp]
  0010b	50		 push	 eax
  0010c	8b 4d 0c	 mov	 ecx, DWORD PTR _database$[ebp]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 _setPointers
  00115	83 c4 08	 add	 esp, 8
  00118	89 45 bc	 mov	 DWORD PTR _entryptr$[ebp], eax

; 245  : 	i=0;

  0011b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 246  : 	for(;i<nLogicalProcessors;i++)

  00122	eb 09		 jmp	 SHORT $LN9@useSpeedTo
$LN8@useSpeedTo:
  00124	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00127	83 c0 01	 add	 eax, 1
  0012a	89 45 b0	 mov	 DWORD PTR _i$[ebp], eax
$LN9@useSpeedTo:
  0012d	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00130	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLogicalProcessors
  00136	0f 8d 82 00 00
	00		 jge	 $LN7@useSpeedTo

; 247  : 	{		
; 248  : 		hThreads[i]=(HANDLE *)malloc(sizeof(HANDLE));

  0013c	8b f4		 mov	 esi, esp
  0013e	6a 04		 push	 4
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00146	83 c4 04	 add	 esp, 4
  00149	3b f4		 cmp	 esi, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	8b 4d b0	 mov	 ecx, DWORD PTR _i$[ebp]
  00153	8b 55 d4	 mov	 edx, DWORD PTR _hThreads$[ebp]
  00156	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 249  : 		packages[i]=setPackage(word,entryptr[i],NULL,NULL, diff-1);

  00159	8b 45 98	 mov	 eax, DWORD PTR _diff$[ebp]
  0015c	83 e8 01	 sub	 eax, 1
  0015f	50		 push	 eax
  00160	6a 00		 push	 0
  00162	6a 00		 push	 0
  00164	8b 4d b0	 mov	 ecx, DWORD PTR _i$[ebp]
  00167	8b 55 bc	 mov	 edx, DWORD PTR _entryptr$[ebp]
  0016a	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0016d	50		 push	 eax
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _word$[ebp]
  00171	51		 push	 ecx
  00172	e8 00 00 00 00	 call	 _setPackage
  00177	83 c4 14	 add	 esp, 20			; 00000014H
  0017a	8b 55 b0	 mov	 edx, DWORD PTR _i$[ebp]
  0017d	8b 4d e0	 mov	 ecx, DWORD PTR _packages$[ebp]
  00180	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 250  : 		*hThreads[i]=(HANDLE) _beginthreadex(NULL,0,searchThreadCounted,(void *)packages[i],0,&threadid);

  00183	8b f4		 mov	 esi, esp
  00185	8d 45 ec	 lea	 eax, DWORD PTR _threadid$[ebp]
  00188	50		 push	 eax
  00189	6a 00		 push	 0
  0018b	8b 4d b0	 mov	 ecx, DWORD PTR _i$[ebp]
  0018e	8b 55 e0	 mov	 edx, DWORD PTR _packages$[ebp]
  00191	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00194	50		 push	 eax
  00195	68 00 00 00 00	 push	 OFFSET _searchThreadCounted@4
  0019a	6a 00		 push	 0
  0019c	6a 00		 push	 0
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthreadex
  001a4	83 c4 18	 add	 esp, 24			; 00000018H
  001a7	3b f4		 cmp	 esi, esp
  001a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ae	8b 4d b0	 mov	 ecx, DWORD PTR _i$[ebp]
  001b1	8b 55 d4	 mov	 edx, DWORD PTR _hThreads$[ebp]
  001b4	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  001b7	89 01		 mov	 DWORD PTR [ecx], eax

; 251  : 	}

  001b9	e9 66 ff ff ff	 jmp	 $LN8@useSpeedTo
$LN7@useSpeedTo:

; 252  : 	for(i=0;i<nLogicalProcessors;i++)

  001be	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001c5	eb 09		 jmp	 SHORT $LN6@useSpeedTo
$LN5@useSpeedTo:
  001c7	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  001ca	83 c0 01	 add	 eax, 1
  001cd	89 45 b0	 mov	 DWORD PTR _i$[ebp], eax
$LN6@useSpeedTo:
  001d0	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  001d3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLogicalProcessors
  001d9	7d 1f		 jge	 SHORT $LN4@useSpeedTo

; 253  : 	{	
; 254  : 		WaitForSingleObject(*hThreads[i],INFINITE);

  001db	8b f4		 mov	 esi, esp
  001dd	6a ff		 push	 -1
  001df	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  001e2	8b 4d d4	 mov	 ecx, DWORD PTR _hThreads$[ebp]
  001e5	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  001e8	8b 02		 mov	 eax, DWORD PTR [edx]
  001ea	50		 push	 eax
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  001f1	3b f4		 cmp	 esi, esp
  001f3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 255  : 	}

  001f8	eb cd		 jmp	 SHORT $LN5@useSpeedTo
$LN4@useSpeedTo:

; 256  : 
; 257  : 	for(i=0;i<nLogicalProcessors;i++)

  001fa	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00201	eb 09		 jmp	 SHORT $LN3@useSpeedTo
$LN2@useSpeedTo:
  00203	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00206	83 c0 01	 add	 eax, 1
  00209	89 45 b0	 mov	 DWORD PTR _i$[ebp], eax
$LN3@useSpeedTo:
  0020c	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  0020f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLogicalProcessors
  00215	0f 8d 81 00 00
	00		 jge	 $LN1@useSpeedTo

; 258  : 	{
; 259  : 		results=addEntryToList(packages[i]->results,results);

  0021b	8b 45 c8	 mov	 eax, DWORD PTR _results$[ebp]
  0021e	50		 push	 eax
  0021f	8b 4d b0	 mov	 ecx, DWORD PTR _i$[ebp]
  00222	8b 55 e0	 mov	 edx, DWORD PTR _packages$[ebp]
  00225	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00228	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0022b	51		 push	 ecx
  0022c	e8 00 00 00 00	 call	 _addEntryToList
  00231	83 c4 08	 add	 esp, 8
  00234	89 45 c8	 mov	 DWORD PTR _results$[ebp], eax

; 260  : 		CloseHandle(*hThreads[i]);

  00237	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  0023a	8b 4d d4	 mov	 ecx, DWORD PTR _hThreads$[ebp]
  0023d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00240	8b f4		 mov	 esi, esp
  00242	8b 02		 mov	 eax, DWORD PTR [edx]
  00244	50		 push	 eax
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0024b	3b f4		 cmp	 esi, esp
  0024d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 261  : 		free(hThreads[i]);

  00252	8b f4		 mov	 esi, esp
  00254	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00257	8b 4d d4	 mov	 ecx, DWORD PTR _hThreads$[ebp]
  0025a	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0025d	52		 push	 edx
  0025e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00264	83 c4 04	 add	 esp, 4
  00267	3b f4		 cmp	 esi, esp
  00269	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 262  : 		free(tab[i]);	

  0026e	8b f4		 mov	 esi, esp
  00270	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00273	8b 4d f8	 mov	 ecx, DWORD PTR _tab$[ebp]
  00276	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00279	52		 push	 edx
  0027a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00280	83 c4 04	 add	 esp, 4
  00283	3b f4		 cmp	 esi, esp
  00285	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 263  : 		entryptr[i]=NULL;

  0028a	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  0028d	8b 4d bc	 mov	 ecx, DWORD PTR _entryptr$[ebp]
  00290	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0

; 264  : 	}

  00297	e9 67 ff ff ff	 jmp	 $LN2@useSpeedTo
$LN1@useSpeedTo:

; 265  : 	free(hThreads);

  0029c	8b f4		 mov	 esi, esp
  0029e	8b 45 d4	 mov	 eax, DWORD PTR _hThreads$[ebp]
  002a1	50		 push	 eax
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  002a8	83 c4 04	 add	 esp, 4
  002ab	3b f4		 cmp	 esi, esp
  002ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 266  : 	free(tab);

  002b2	8b f4		 mov	 esi, esp
  002b4	8b 45 f8	 mov	 eax, DWORD PTR _tab$[ebp]
  002b7	50		 push	 eax
  002b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  002be	83 c4 04	 add	 esp, 4
  002c1	3b f4		 cmp	 esi, esp
  002c3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 267  : 	free(entryptr);

  002c8	8b f4		 mov	 esi, esp
  002ca	8b 45 bc	 mov	 eax, DWORD PTR _entryptr$[ebp]
  002cd	50		 push	 eax
  002ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  002d4	83 c4 04	 add	 esp, 4
  002d7	3b f4		 cmp	 esi, esp
  002d9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 268  : 	return results;

  002de	8b 45 c8	 mov	 eax, DWORD PTR _results$[ebp]

; 269  : }

  002e1	52		 push	 edx
  002e2	8b cd		 mov	 ecx, ebp
  002e4	50		 push	 eax
  002e5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@useSpeedTo
  002eb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002f0	58		 pop	 eax
  002f1	5a		 pop	 edx
  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi
  002f4	5b		 pop	 ebx
  002f5	81 c4 44 01 00
	00		 add	 esp, 324		; 00000144H
  002fb	3b ec		 cmp	 ebp, esp
  002fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c3		 ret	 0
  00306	8b ff		 npad	 2
$LN17@useSpeedTo:
  00308	01 00 00 00	 DD	 1
  0030c	00 00 00 00	 DD	 $LN16@useSpeedTo
$LN16@useSpeedTo:
  00310	ec ff ff ff	 DD	 -20			; ffffffecH
  00314	04 00 00 00	 DD	 4
  00318	00 00 00 00	 DD	 $LN15@useSpeedTo
$LN15@useSpeedTo:
  0031c	74		 DB	 116			; 00000074H
  0031d	68		 DB	 104			; 00000068H
  0031e	72		 DB	 114			; 00000072H
  0031f	65		 DB	 101			; 00000065H
  00320	61		 DB	 97			; 00000061H
  00321	64		 DB	 100			; 00000064H
  00322	69		 DB	 105			; 00000069H
  00323	64		 DB	 100			; 00000064H
  00324	00		 DB	 0
_useSpeedToFindOneFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _startProgramWithThreads
_TEXT	SEGMENT
tv80 = -352						; size = 4
_database$ = -152					; size = 4
_packages$ = -140					; size = 4
_hThreads$ = -128					; size = 4
_filename$ = -116					; size = 11
_threadid$ = -96					; size = 4
_lastfor$ = -84						; size = 4
_counter$ = -72						; size = 4
_threadcounter$ = -60					; size = 4
_listlength$ = -48					; size = 4
_results$ = -36						; size = 4
_fileptr2$ = -24					; size = 4
_fileptr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_wordtofind$ = 8					; size = 4
_outputfilename$ = 12					; size = 4
_startProgramWithThreads PROC				; COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-352]
  00012	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 157  : 	FILE * fileptr=NULL,*fileptr2=NULL;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fileptr$[ebp], 0
  0002f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _fileptr2$[ebp], 0

; 158  : 	Entry *results=NULL;

  00036	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _results$[ebp], 0

; 159  : 	int listlength=0, threadcounter=0, counter=0, lastfor=nLogicalProcessors=readNumberOfLogicalUnits();

  0003d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _listlength$[ebp], 0
  00044	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _threadcounter$[ebp], 0
  0004b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _counter$[ebp], 0
  00052	e8 00 00 00 00	 call	 _readNumberOfLogicalUnits
  00057	a3 00 00 00 00	 mov	 DWORD PTR _nLogicalProcessors, eax
  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR _nLogicalProcessors
  00061	89 45 ac	 mov	 DWORD PTR _lastfor$[ebp], eax

; 160  : 	unsigned int threadid=0;

  00064	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _threadid$[ebp], 0

; 161  : 	char filename[]=STORE_START;

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@
  00070	89 45 8c	 mov	 DWORD PTR _filename$[ebp], eax
  00073	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@+4
  00079	89 4d 90	 mov	 DWORD PTR _filename$[ebp+4], ecx
  0007c	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@+8
  00083	66 89 55 94	 mov	 WORD PTR _filename$[ebp+8], dx
  00087	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@+10
  0008c	88 45 96	 mov	 BYTE PTR _filename$[ebp+10], al

; 162  : 	HANDLE ** hThreads=(HANDLE **)calloc(nLogicalProcessors,sizeof(HANDLE *));

  0008f	8b f4		 mov	 esi, esp
  00091	6a 04		 push	 4
  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _nLogicalProcessors
  00098	50		 push	 eax
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0009f	83 c4 08	 add	 esp, 8
  000a2	3b f4		 cmp	 esi, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	89 45 80	 mov	 DWORD PTR _hThreads$[ebp], eax

; 163  : 	Package ** packages=(Package **)calloc(nLogicalProcessors,sizeof(Package *));

  000ac	8b f4		 mov	 esi, esp
  000ae	6a 04		 push	 4
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _nLogicalProcessors
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  000bc	83 c4 08	 add	 esp, 8
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	89 85 74 ff ff
	ff		 mov	 DWORD PTR _packages$[ebp], eax

; 164  : 	Entry ** database=(Entry **) calloc(nLogicalProcessors,sizeof(Entry *));

  000cc	8b f4		 mov	 esi, esp
  000ce	6a 04		 push	 4
  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _nLogicalProcessors
  000d5	50		 push	 eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  000dc	83 c4 08	 add	 esp, 8
  000df	3b f4		 cmp	 esi, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e6	89 85 68 ff ff
	ff		 mov	 DWORD PTR _database$[ebp], eax

; 165  : 	nLogicalProcessors=(nLogicalProcessors==0 ? 1 : nLogicalProcessors);

  000ec	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _nLogicalProcessors, 0
  000f3	75 0c		 jne	 SHORT $LN21@startProgr
  000f5	c7 85 a0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv80[ebp], 1
  000ff	eb 0b		 jmp	 SHORT $LN22@startProgr
$LN21@startProgr:
  00101	a1 00 00 00 00	 mov	 eax, DWORD PTR _nLogicalProcessors
  00106	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
$LN22@startProgr:
  0010c	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR tv80[ebp]
  00112	89 0d 00 00 00
	00		 mov	 DWORD PTR _nLogicalProcessors, ecx

; 166  : 	printf("Tryb szybki... \n");

  00118	8b f4		 mov	 esi, esp
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JMANOGFA@Tryb?5szybki?4?4?4?5?6?$AA@
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00125	83 c4 04	 add	 esp, 4
  00128	3b f4		 cmp	 esi, esp
  0012a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 167  : 	startTimefull=timeGetTime();

  0012f	8b f4		 mov	 esi, esp
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00137	3b f4		 cmp	 esi, esp
  00139	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013e	a3 00 00 00 00	 mov	 DWORD PTR _startTimefull, eax
$LN18@startProgr:

; 168  : 	while(1)

  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	85 c0		 test	 eax, eax
  0014a	0f 84 3c 02 00
	00		 je	 $LN17@startProgr
$LN16@startProgr:

; 169  : 	{
; 170  : 		while(threadcounter < nLogicalProcessors)

  00150	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  00153	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLogicalProcessors
  00159	0f 8d 09 01 00
	00		 jge	 $LN15@startProgr

; 171  : 		{
; 172  : 			printf("%s\n",filename);

  0015f	8b f4		 mov	 esi, esp
  00161	8d 45 8c	 lea	 eax, DWORD PTR _filename$[ebp]
  00164	50		 push	 eax
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00170	83 c4 08	 add	 esp, 8
  00173	3b f4		 cmp	 esi, esp
  00175	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 173  : 			fileptr=openFileAndGetNumberOfElements(filename,&listlength);

  0017a	8d 45 d0	 lea	 eax, DWORD PTR _listlength$[ebp]
  0017d	50		 push	 eax
  0017e	8d 4d 8c	 lea	 ecx, DWORD PTR _filename$[ebp]
  00181	51		 push	 ecx
  00182	e8 00 00 00 00	 call	 _openFileAndGetNumberOfElements
  00187	83 c4 08	 add	 esp, 8
  0018a	89 45 f4	 mov	 DWORD PTR _fileptr$[ebp], eax

; 174  : 			hThreads[threadcounter]=(HANDLE *)malloc(sizeof(HANDLE));

  0018d	8b f4		 mov	 esi, esp
  0018f	6a 04		 push	 4
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00197	83 c4 04	 add	 esp, 4
  0019a	3b f4		 cmp	 esi, esp
  0019c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a1	8b 4d c4	 mov	 ecx, DWORD PTR _threadcounter$[ebp]
  001a4	8b 55 80	 mov	 edx, DWORD PTR _hThreads$[ebp]
  001a7	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 175  : 			packages[threadcounter]=setPackage(wordtofind,NULL,NULL,fileptr,0);

  001aa	6a 00		 push	 0
  001ac	8b 45 f4	 mov	 eax, DWORD PTR _fileptr$[ebp]
  001af	50		 push	 eax
  001b0	6a 00		 push	 0
  001b2	6a 00		 push	 0
  001b4	8b 4d 08	 mov	 ecx, DWORD PTR _wordtofind$[ebp]
  001b7	51		 push	 ecx
  001b8	e8 00 00 00 00	 call	 _setPackage
  001bd	83 c4 14	 add	 esp, 20			; 00000014H
  001c0	8b 55 c4	 mov	 edx, DWORD PTR _threadcounter$[ebp]
  001c3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _packages$[ebp]
  001c9	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 176  : 			if(fileptr!=NULL)

  001cc	83 7d f4 00	 cmp	 DWORD PTR _fileptr$[ebp], 0
  001d0	74 3b		 je	 SHORT $LN14@startProgr

; 177  : 				*hThreads[threadcounter]=(HANDLE) _beginthreadex(NULL,0,searchThreadUncounted,(void *)packages[threadcounter],0,&threadid);

  001d2	8b f4		 mov	 esi, esp
  001d4	8d 45 a0	 lea	 eax, DWORD PTR _threadid$[ebp]
  001d7	50		 push	 eax
  001d8	6a 00		 push	 0
  001da	8b 4d c4	 mov	 ecx, DWORD PTR _threadcounter$[ebp]
  001dd	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _packages$[ebp]
  001e3	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  001e6	50		 push	 eax
  001e7	68 00 00 00 00	 push	 OFFSET _searchThreadUncounted@4
  001ec	6a 00		 push	 0
  001ee	6a 00		 push	 0
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthreadex
  001f6	83 c4 18	 add	 esp, 24			; 00000018H
  001f9	3b f4		 cmp	 esi, esp
  001fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00200	8b 4d c4	 mov	 ecx, DWORD PTR _threadcounter$[ebp]
  00203	8b 55 80	 mov	 edx, DWORD PTR _hThreads$[ebp]
  00206	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00209	89 01		 mov	 DWORD PTR [ecx], eax
  0020b	eb 0f		 jmp	 SHORT $LN13@startProgr
$LN14@startProgr:

; 178  : 			else *hThreads[threadcounter]=0;

  0020d	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  00210	8b 4d 80	 mov	 ecx, DWORD PTR _hThreads$[ebp]
  00213	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00216	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN13@startProgr:

; 179  : 
; 180  : 			counter++;

  0021c	8b 45 b8	 mov	 eax, DWORD PTR _counter$[ebp]
  0021f	83 c0 01	 add	 eax, 1
  00222	89 45 b8	 mov	 DWORD PTR _counter$[ebp], eax

; 181  : 			threadcounter++;

  00225	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  00228	83 c0 01	 add	 eax, 1
  0022b	89 45 c4	 mov	 DWORD PTR _threadcounter$[ebp], eax

; 182  : 			filename[5]++;			

  0022e	b8 01 00 00 00	 mov	 eax, 1
  00233	6b c0 05	 imul	 eax, 5
  00236	8a 4c 05 8c	 mov	 cl, BYTE PTR _filename$[ebp+eax]
  0023a	80 c1 01	 add	 cl, 1
  0023d	ba 01 00 00 00	 mov	 edx, 1
  00242	6b d2 05	 imul	 edx, 5
  00245	88 4c 15 8c	 mov	 BYTE PTR _filename$[ebp+edx], cl

; 183  : 			if(filename[5]>'Z')

  00249	b8 01 00 00 00	 mov	 eax, 1
  0024e	6b c0 05	 imul	 eax, 5
  00251	0f be 4c 05 8c	 movsx	 ecx, BYTE PTR _filename$[ebp+eax]
  00256	83 f9 5a	 cmp	 ecx, 90			; 0000005aH
  00259	7e 08		 jle	 SHORT $LN12@startProgr

; 184  : 			{
; 185  : 				lastfor=threadcounter;

  0025b	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  0025e	89 45 ac	 mov	 DWORD PTR _lastfor$[ebp], eax

; 186  : 				break;

  00261	eb 05		 jmp	 SHORT $LN15@startProgr
$LN12@startProgr:

; 187  : 			}
; 188  : 		}

  00263	e9 e8 fe ff ff	 jmp	 $LN16@startProgr
$LN15@startProgr:

; 189  : 
; 190  : 		for(threadcounter=0;(threadcounter < nLogicalProcessors) && (threadcounter < lastfor)  ; threadcounter++)

  00268	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _threadcounter$[ebp], 0
  0026f	eb 09		 jmp	 SHORT $LN11@startProgr
$LN10@startProgr:
  00271	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  00274	83 c0 01	 add	 eax, 1
  00277	89 45 c4	 mov	 DWORD PTR _threadcounter$[ebp], eax
$LN11@startProgr:
  0027a	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  0027d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLogicalProcessors
  00283	7d 27		 jge	 SHORT $LN9@startProgr
  00285	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  00288	3b 45 ac	 cmp	 eax, DWORD PTR _lastfor$[ebp]
  0028b	7d 1f		 jge	 SHORT $LN9@startProgr

; 191  : 		{
; 192  : 			WaitForSingleObject(*hThreads[threadcounter],INFINITE);

  0028d	8b f4		 mov	 esi, esp
  0028f	6a ff		 push	 -1
  00291	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  00294	8b 4d 80	 mov	 ecx, DWORD PTR _hThreads$[ebp]
  00297	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0029a	8b 02		 mov	 eax, DWORD PTR [edx]
  0029c	50		 push	 eax
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  002a3	3b f4		 cmp	 esi, esp
  002a5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 193  : 		}

  002aa	eb c5		 jmp	 SHORT $LN10@startProgr
$LN9@startProgr:

; 194  : 
; 195  : 		for(threadcounter=0;(threadcounter < nLogicalProcessors) && (threadcounter < lastfor); threadcounter++)

  002ac	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _threadcounter$[ebp], 0
  002b3	eb 09		 jmp	 SHORT $LN8@startProgr
$LN7@startProgr:
  002b5	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  002b8	83 c0 01	 add	 eax, 1
  002bb	89 45 c4	 mov	 DWORD PTR _threadcounter$[ebp], eax
$LN8@startProgr:
  002be	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  002c1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLogicalProcessors
  002c7	0f 8d a9 00 00
	00		 jge	 $LN6@startProgr
  002cd	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  002d0	3b 45 ac	 cmp	 eax, DWORD PTR _lastfor$[ebp]
  002d3	0f 8d 9d 00 00
	00		 jge	 $LN6@startProgr

; 196  : 		{
; 197  : 			results=addEntryToList(packages[threadcounter]->results,results);

  002d9	8b 45 dc	 mov	 eax, DWORD PTR _results$[ebp]
  002dc	50		 push	 eax
  002dd	8b 4d c4	 mov	 ecx, DWORD PTR _threadcounter$[ebp]
  002e0	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _packages$[ebp]
  002e6	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  002e9	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002ec	51		 push	 ecx
  002ed	e8 00 00 00 00	 call	 _addEntryToList
  002f2	83 c4 08	 add	 esp, 8
  002f5	89 45 dc	 mov	 DWORD PTR _results$[ebp], eax

; 198  : 			if(*hThreads[threadcounter]!=0)

  002f8	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  002fb	8b 4d 80	 mov	 ecx, DWORD PTR _hThreads$[ebp]
  002fe	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00301	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00304	74 1b		 je	 SHORT $LN5@startProgr

; 199  : 				CloseHandle(*hThreads[threadcounter]);

  00306	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  00309	8b 4d 80	 mov	 ecx, DWORD PTR _hThreads$[ebp]
  0030c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0030f	8b f4		 mov	 esi, esp
  00311	8b 02		 mov	 eax, DWORD PTR [edx]
  00313	50		 push	 eax
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0031a	3b f4		 cmp	 esi, esp
  0031c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@startProgr:

; 200  : 			free(hThreads[threadcounter]);

  00321	8b f4		 mov	 esi, esp
  00323	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  00326	8b 4d 80	 mov	 ecx, DWORD PTR _hThreads$[ebp]
  00329	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0032c	52		 push	 edx
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00333	83 c4 04	 add	 esp, 4
  00336	3b f4		 cmp	 esi, esp
  00338	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 201  : 			free(database[threadcounter]);

  0033d	8b f4		 mov	 esi, esp
  0033f	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  00342	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _database$[ebp]
  00348	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0034b	52		 push	 edx
  0034c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00352	83 c4 04	 add	 esp, 4
  00355	3b f4		 cmp	 esi, esp
  00357	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 202  : 			deletePackage(packages[threadcounter]);

  0035c	8b 45 c4	 mov	 eax, DWORD PTR _threadcounter$[ebp]
  0035f	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _packages$[ebp]
  00365	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00368	52		 push	 edx
  00369	e8 00 00 00 00	 call	 _deletePackage
  0036e	83 c4 04	 add	 esp, 4

; 203  : 		}

  00371	e9 3f ff ff ff	 jmp	 $LN7@startProgr
$LN6@startProgr:

; 204  : 		
; 205  : 		if(counter>=LETTERS_NUMBER)

  00376	83 7d b8 19	 cmp	 DWORD PTR _counter$[ebp], 25 ; 00000019H
  0037a	7c 04		 jl	 SHORT $LN4@startProgr

; 206  : 			break;

  0037c	eb 0e		 jmp	 SHORT $LN17@startProgr

; 207  : 		else

  0037e	eb 07		 jmp	 SHORT $LN3@startProgr
$LN4@startProgr:

; 208  : 			threadcounter=0;

  00380	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _threadcounter$[ebp], 0
$LN3@startProgr:

; 209  : 	}

  00387	e9 b7 fd ff ff	 jmp	 $LN18@startProgr
$LN17@startProgr:

; 210  : 	endTimefull=timeGetTime();

  0038c	8b f4		 mov	 esi, esp
  0038e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00394	3b f4		 cmp	 esi, esp
  00396	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0039b	a3 00 00 00 00	 mov	 DWORD PTR _endTimefull, eax

; 211  : 	resultTime=(endTimefull-startTimefull);

  003a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _endTimefull
  003a5	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _startTimefull
  003ab	a3 00 00 00 00	 mov	 DWORD PTR _resultTime, eax

; 212  : 	printf("Execution time for %d units: %d\n", nLogicalProcessors, resultTime);

  003b0	8b f4		 mov	 esi, esp
  003b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _resultTime
  003b7	50		 push	 eax
  003b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nLogicalProcessors
  003be	51		 push	 ecx
  003bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JHNJPOB@Execution?5time?5for?5?$CFd?5units?3?5?$CFd?6@
  003c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  003ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  003cd	3b f4		 cmp	 esi, esp
  003cf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 213  : 	getchar();

  003d4	8b f4		 mov	 esi, esp
  003d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getchar
  003dc	3b f4		 cmp	 esi, esp
  003de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 214  : 	if(outputfilename!=NULL)

  003e3	83 7d 0c 00	 cmp	 DWORD PTR _outputfilename$[ebp], 0
  003e7	74 18		 je	 SHORT $LN2@startProgr

; 215  : 	output(results,2,fileptr2,outputfilename);

  003e9	8b 45 0c	 mov	 eax, DWORD PTR _outputfilename$[ebp]
  003ec	50		 push	 eax
  003ed	8b 4d e8	 mov	 ecx, DWORD PTR _fileptr2$[ebp]
  003f0	51		 push	 ecx
  003f1	6a 02		 push	 2
  003f3	8b 55 dc	 mov	 edx, DWORD PTR _results$[ebp]
  003f6	52		 push	 edx
  003f7	e8 00 00 00 00	 call	 _output
  003fc	83 c4 10	 add	 esp, 16			; 00000010H

; 216  : 	else 

  003ff	eb 12		 jmp	 SHORT $LN1@startProgr
$LN2@startProgr:

; 217  : 	output(results,1,NULL,NULL);

  00401	6a 00		 push	 0
  00403	6a 00		 push	 0
  00405	6a 01		 push	 1
  00407	8b 45 dc	 mov	 eax, DWORD PTR _results$[ebp]
  0040a	50		 push	 eax
  0040b	e8 00 00 00 00	 call	 _output
  00410	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@startProgr:

; 218  : 	fflush(stdin);

  00413	8b f4		 mov	 esi, esp
  00415	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0041b	3b f4		 cmp	 esi, esp
  0041d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00422	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00427	6b c9 00	 imul	 ecx, 0
  0042a	03 c1		 add	 eax, ecx
  0042c	8b f4		 mov	 esi, esp
  0042e	50		 push	 eax
  0042f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00435	83 c4 04	 add	 esp, 4
  00438	3b f4		 cmp	 esi, esp
  0043a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 219  : 	getchar();

  0043f	8b f4		 mov	 esi, esp
  00441	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getchar
  00447	3b f4		 cmp	 esi, esp
  00449	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 220  : 	clean(results);

  0044e	8b 45 dc	 mov	 eax, DWORD PTR _results$[ebp]
  00451	50		 push	 eax
  00452	e8 00 00 00 00	 call	 _clean
  00457	83 c4 04	 add	 esp, 4

; 221  : 	free(packages);

  0045a	8b f4		 mov	 esi, esp
  0045c	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _packages$[ebp]
  00462	50		 push	 eax
  00463	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00469	83 c4 04	 add	 esp, 4
  0046c	3b f4		 cmp	 esi, esp
  0046e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 222  : 	free(hThreads);

  00473	8b f4		 mov	 esi, esp
  00475	8b 45 80	 mov	 eax, DWORD PTR _hThreads$[ebp]
  00478	50		 push	 eax
  00479	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0047f	83 c4 04	 add	 esp, 4
  00482	3b f4		 cmp	 esi, esp
  00484	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 223  : 	free(database);

  00489	8b f4		 mov	 esi, esp
  0048b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _database$[ebp]
  00491	50		 push	 eax
  00492	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00498	83 c4 04	 add	 esp, 4
  0049b	3b f4		 cmp	 esi, esp
  0049d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 224  : }

  004a2	52		 push	 edx
  004a3	8b cd		 mov	 ecx, ebp
  004a5	50		 push	 eax
  004a6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN27@startProgr
  004ac	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004b1	58		 pop	 eax
  004b2	5a		 pop	 edx
  004b3	5f		 pop	 edi
  004b4	5e		 pop	 esi
  004b5	5b		 pop	 ebx
  004b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b9	33 cd		 xor	 ecx, ebp
  004bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c0	81 c4 60 01 00
	00		 add	 esp, 352		; 00000160H
  004c6	3b ec		 cmp	 ebp, esp
  004c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004cd	8b e5		 mov	 esp, ebp
  004cf	5d		 pop	 ebp
  004d0	c3		 ret	 0
  004d1	8d 49 00	 npad	 3
$LN27@startProgr:
  004d4	03 00 00 00	 DD	 3
  004d8	00 00 00 00	 DD	 $LN26@startProgr
$LN26@startProgr:
  004dc	d0 ff ff ff	 DD	 -48			; ffffffd0H
  004e0	04 00 00 00	 DD	 4
  004e4	00 00 00 00	 DD	 $LN23@startProgr
  004e8	a0 ff ff ff	 DD	 -96			; ffffffa0H
  004ec	04 00 00 00	 DD	 4
  004f0	00 00 00 00	 DD	 $LN24@startProgr
  004f4	8c ff ff ff	 DD	 -116			; ffffff8cH
  004f8	0b 00 00 00	 DD	 11			; 0000000bH
  004fc	00 00 00 00	 DD	 $LN25@startProgr
$LN25@startProgr:
  00500	66		 DB	 102			; 00000066H
  00501	69		 DB	 105			; 00000069H
  00502	6c		 DB	 108			; 0000006cH
  00503	65		 DB	 101			; 00000065H
  00504	6e		 DB	 110			; 0000006eH
  00505	61		 DB	 97			; 00000061H
  00506	6d		 DB	 109			; 0000006dH
  00507	65		 DB	 101			; 00000065H
  00508	00		 DB	 0
$LN24@startProgr:
  00509	74		 DB	 116			; 00000074H
  0050a	68		 DB	 104			; 00000068H
  0050b	72		 DB	 114			; 00000072H
  0050c	65		 DB	 101			; 00000065H
  0050d	61		 DB	 97			; 00000061H
  0050e	64		 DB	 100			; 00000064H
  0050f	69		 DB	 105			; 00000069H
  00510	64		 DB	 100			; 00000064H
  00511	00		 DB	 0
$LN23@startProgr:
  00512	6c		 DB	 108			; 0000006cH
  00513	69		 DB	 105			; 00000069H
  00514	73		 DB	 115			; 00000073H
  00515	74		 DB	 116			; 00000074H
  00516	6c		 DB	 108			; 0000006cH
  00517	65		 DB	 101			; 00000065H
  00518	6e		 DB	 110			; 0000006eH
  00519	67		 DB	 103			; 00000067H
  0051a	74		 DB	 116			; 00000074H
  0051b	68		 DB	 104			; 00000068H
  0051c	00		 DB	 0
_startProgramWithThreads ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _startProgram
_TEXT	SEGMENT
_filename$ = -80					; size = 11
_listlength$ = -60					; size = 4
_result$ = -48						; size = 4
_database$ = -36					; size = 4
_fileptr2$ = -24					; size = 4
_fileptr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_wordtofind$ = 8					; size = 4
_outputfilename$ = 12					; size = 4
_startProgram PROC					; COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 126  : 	FILE * fileptr=NULL,*fileptr2=NULL;

  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fileptr$[ebp], 0
  0002f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _fileptr2$[ebp], 0

; 127  : 	Entry * database=NULL,*result=NULL;

  00036	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _database$[ebp], 0
  0003d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0

; 128  : 	int listlength=0;

  00044	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _listlength$[ebp], 0

; 129  : 	char filename[]=STORE_START;

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@
  00050	89 45 b0	 mov	 DWORD PTR _filename$[ebp], eax
  00053	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@+4
  00059	89 4d b4	 mov	 DWORD PTR _filename$[ebp+4], ecx
  0005c	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@+8
  00063	66 89 55 b8	 mov	 WORD PTR _filename$[ebp+8], dx
  00067	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0L@FADCIPKF@data?2A?4txt?$AA@+10
  0006c	88 45 ba	 mov	 BYTE PTR _filename$[ebp+10], al

; 130  : 	printf("Tryb normalny.. \n");

  0006f	8b f4		 mov	 esi, esp
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HJOJEJNA@Tryb?5normalny?4?4?5?6?$AA@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0007c	83 c4 04	 add	 esp, 4
  0007f	3b f4		 cmp	 esi, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 131  : 	startTimefull=timeGetTime();

  00086	8b f4		 mov	 esi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	a3 00 00 00 00	 mov	 DWORD PTR _startTimefull, eax

; 132  : 
; 133  : 	for(;filename[5]<=90;filename[5]++)

  0009a	eb 1b		 jmp	 SHORT $LN6@startProgr
$LN5@startProgr:
  0009c	b8 01 00 00 00	 mov	 eax, 1
  000a1	6b c0 05	 imul	 eax, 5
  000a4	8a 4c 05 b0	 mov	 cl, BYTE PTR _filename$[ebp+eax]
  000a8	80 c1 01	 add	 cl, 1
  000ab	ba 01 00 00 00	 mov	 edx, 1
  000b0	6b d2 05	 imul	 edx, 5
  000b3	88 4c 15 b0	 mov	 BYTE PTR _filename$[ebp+edx], cl
$LN6@startProgr:
  000b7	b8 01 00 00 00	 mov	 eax, 1
  000bc	6b c0 05	 imul	 eax, 5
  000bf	0f be 4c 05 b0	 movsx	 ecx, BYTE PTR _filename$[ebp+eax]
  000c4	83 f9 5a	 cmp	 ecx, 90			; 0000005aH
  000c7	7f 68		 jg	 SHORT $LN4@startProgr

; 134  : 	{
; 135  : 		fileptr=openFileAndGetNumberOfElements(filename,&listlength);

  000c9	8d 45 c4	 lea	 eax, DWORD PTR _listlength$[ebp]
  000cc	50		 push	 eax
  000cd	8d 4d b0	 lea	 ecx, DWORD PTR _filename$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _openFileAndGetNumberOfElements
  000d6	83 c4 08	 add	 esp, 8
  000d9	89 45 f4	 mov	 DWORD PTR _fileptr$[ebp], eax

; 136  : 		printf("%s\n",filename);

  000dc	8b f4		 mov	 esi, esp
  000de	8d 45 b0	 lea	 eax, DWORD PTR _filename$[ebp]
  000e1	50		 push	 eax
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  000ed	83 c4 08	 add	 esp, 8
  000f0	3b f4		 cmp	 esi, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 137  : 		database=readEntriesFromFile(fileptr);

  000f7	8b 45 f4	 mov	 eax, DWORD PTR _fileptr$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _readEntriesFromFile
  00100	83 c4 04	 add	 esp, 4
  00103	89 45 dc	 mov	 DWORD PTR _database$[ebp], eax

; 138  : 		if(database!=NULL)			

  00106	83 7d dc 00	 cmp	 DWORD PTR _database$[ebp], 0
  0010a	74 20		 je	 SHORT $LN3@startProgr

; 139  : 			result=addEntryToList(findAllEntries(wordtofind,database),result);

  0010c	8b 45 d0	 mov	 eax, DWORD PTR _result$[ebp]
  0010f	50		 push	 eax
  00110	8b 4d dc	 mov	 ecx, DWORD PTR _database$[ebp]
  00113	51		 push	 ecx
  00114	8b 55 08	 mov	 edx, DWORD PTR _wordtofind$[ebp]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 _findAllEntries
  0011d	83 c4 08	 add	 esp, 8
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 _addEntryToList
  00126	83 c4 08	 add	 esp, 8
  00129	89 45 d0	 mov	 DWORD PTR _result$[ebp], eax
$LN3@startProgr:

; 140  : 	}

  0012c	e9 6b ff ff ff	 jmp	 $LN5@startProgr
$LN4@startProgr:

; 141  : 	endTimefull=timeGetTime();

  00131	8b f4		 mov	 esi, esp
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeGetTime@0
  00139	3b f4		 cmp	 esi, esp
  0013b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00140	a3 00 00 00 00	 mov	 DWORD PTR _endTimefull, eax

; 142  : 	resultTime=(endTimefull-startTimefull);

  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR _endTimefull
  0014a	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _startTimefull
  00150	a3 00 00 00 00	 mov	 DWORD PTR _resultTime, eax

; 143  : 	printf("Execution time for %d units: %d\n", nLogicalProcessors, resultTime);

  00155	8b f4		 mov	 esi, esp
  00157	a1 00 00 00 00	 mov	 eax, DWORD PTR _resultTime
  0015c	50		 push	 eax
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nLogicalProcessors
  00163	51		 push	 ecx
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JHNJPOB@Execution?5time?5for?5?$CFd?5units?3?5?$CFd?6@
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00172	3b f4		 cmp	 esi, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 144  : 	getchar();

  00179	8b f4		 mov	 esi, esp
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getchar
  00181	3b f4		 cmp	 esi, esp
  00183	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 145  : 	if(outputfilename!=NULL)

  00188	83 7d 0c 00	 cmp	 DWORD PTR _outputfilename$[ebp], 0
  0018c	74 18		 je	 SHORT $LN2@startProgr

; 146  : 		output(result,2,fileptr2,outputfilename);

  0018e	8b 45 0c	 mov	 eax, DWORD PTR _outputfilename$[ebp]
  00191	50		 push	 eax
  00192	8b 4d e8	 mov	 ecx, DWORD PTR _fileptr2$[ebp]
  00195	51		 push	 ecx
  00196	6a 02		 push	 2
  00198	8b 55 d0	 mov	 edx, DWORD PTR _result$[ebp]
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 _output
  001a1	83 c4 10	 add	 esp, 16			; 00000010H

; 147  : 	else 

  001a4	eb 12		 jmp	 SHORT $LN1@startProgr
$LN2@startProgr:

; 148  : 		output(result,1,NULL,NULL);

  001a6	6a 00		 push	 0
  001a8	6a 00		 push	 0
  001aa	6a 01		 push	 1
  001ac	8b 45 d0	 mov	 eax, DWORD PTR _result$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _output
  001b5	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@startProgr:

; 149  : 	
; 150  : 	printf("\n");

  001b8	8b f4		 mov	 esi, esp
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  001c5	83 c4 04	 add	 esp, 4
  001c8	3b f4		 cmp	 esi, esp
  001ca	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 151  : 	clean(result);

  001cf	8b 45 d0	 mov	 eax, DWORD PTR _result$[ebp]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 _clean
  001d8	83 c4 04	 add	 esp, 4

; 152  : 
; 153  : 
; 154  : }

  001db	52		 push	 edx
  001dc	8b cd		 mov	 ecx, ebp
  001de	50		 push	 eax
  001df	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@startProgr
  001e5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ea	58		 pop	 eax
  001eb	5a		 pop	 edx
  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	5b		 pop	 ebx
  001ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f2	33 cd		 xor	 ecx, ebp
  001f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f9	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  001ff	3b ec		 cmp	 ebp, esp
  00201	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
  0020a	8b ff		 npad	 2
$LN12@startProgr:
  0020c	02 00 00 00	 DD	 2
  00210	00 00 00 00	 DD	 $LN11@startProgr
$LN11@startProgr:
  00214	c4 ff ff ff	 DD	 -60			; ffffffc4H
  00218	04 00 00 00	 DD	 4
  0021c	00 00 00 00	 DD	 $LN9@startProgr
  00220	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00224	0b 00 00 00	 DD	 11			; 0000000bH
  00228	00 00 00 00	 DD	 $LN10@startProgr
$LN10@startProgr:
  0022c	66		 DB	 102			; 00000066H
  0022d	69		 DB	 105			; 00000069H
  0022e	6c		 DB	 108			; 0000006cH
  0022f	65		 DB	 101			; 00000065H
  00230	6e		 DB	 110			; 0000006eH
  00231	61		 DB	 97			; 00000061H
  00232	6d		 DB	 109			; 0000006dH
  00233	65		 DB	 101			; 00000065H
  00234	00		 DB	 0
$LN9@startProgr:
  00235	6c		 DB	 108			; 0000006cH
  00236	69		 DB	 105			; 00000069H
  00237	73		 DB	 115			; 00000073H
  00238	74		 DB	 116			; 00000074H
  00239	6c		 DB	 108			; 0000006cH
  0023a	65		 DB	 101			; 00000065H
  0023b	6e		 DB	 110			; 0000006eH
  0023c	67		 DB	 103			; 00000067H
  0023d	74		 DB	 116			; 00000074H
  0023e	68		 DB	 104			; 00000068H
  0023f	00		 DB	 0
_startProgram ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _clean
_TEXT	SEGMENT
_tmp$ = -8						; size = 4
_database$ = 8						; size = 4
_clean	PROC						; COMDAT

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 109  : 	Entry * tmp=NULL;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tmp$[ebp], 0

; 110  : 
; 111  : 	if(database==NULL)

  00025	83 7d 08 00	 cmp	 DWORD PTR _database$[ebp], 0
  00029	75 02		 jne	 SHORT $LN2@clean

; 112  : 		return;

  0002b	eb 55		 jmp	 SHORT $LN4@clean
$LN2@clean:

; 113  : 	while(database!=NULL)

  0002d	83 7d 08 00	 cmp	 DWORD PTR _database$[ebp], 0
  00031	74 4f		 je	 SHORT $LN4@clean

; 114  : 	{
; 115  : 		tmp=database;

  00033	8b 45 08	 mov	 eax, DWORD PTR _database$[ebp]
  00036	89 45 f8	 mov	 DWORD PTR _tmp$[ebp], eax

; 116  : 		database=database->next;

  00039	8b 45 08	 mov	 eax, DWORD PTR _database$[ebp]
  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	89 4d 08	 mov	 DWORD PTR _database$[ebp], ecx

; 117  : 		free(tmp->word);

  00042	8b f4		 mov	 esi, esp
  00044	8b 45 f8	 mov	 eax, DWORD PTR _tmp$[ebp]
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00050	83 c4 04	 add	 esp, 4
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 118  : 		tmp->word=NULL;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _tmp$[ebp]
  0005d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 119  : 		free(tmp);

  00063	8b f4		 mov	 esi, esp
  00065	8b 45 f8	 mov	 eax, DWORD PTR _tmp$[ebp]
  00068	50		 push	 eax
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0006f	83 c4 04	 add	 esp, 4
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 120  : 		tmp=NULL;

  00079	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tmp$[ebp], 0

; 121  : 	}

  00080	eb ab		 jmp	 SHORT $LN2@clean
$LN4@clean:

; 122  : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
_clean	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _outputDatabaseFile
_TEXT	SEGMENT
_tmpfile$ = -20						; size = 4
_tmp$ = -8						; size = 4
_database$ = 8						; size = 4
_fileptr$ = 12						; size = 4
_filename$ = 16						; size = 4
_outputDatabaseFile PROC				; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 89   : 	char * tmp=(char *) malloc(sizeof(char) * MAX_LENGTH_WORD);

  0001e	8b f4		 mov	 esi, esp
  00020	6a 20		 push	 32			; 00000020H
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00028	83 c4 04	 add	 esp, 4
  0002b	3b f4		 cmp	 esi, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	89 45 f8	 mov	 DWORD PTR _tmp$[ebp], eax

; 90   : 	FILE * tmpfile=NULL;

  00035	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tmpfile$[ebp], 0

; 91   : 	if(database!=NULL)

  0003c	83 7d 08 00	 cmp	 DWORD PTR _database$[ebp], 0
  00040	0f 84 bd 00 00
	00		 je	 $LN3@outputData

; 92   : 	{
; 93   : 		tmpfile=fopen(filename,"w");//zmiana freopen na fopen

  00046	8b f4		 mov	 esi, esp
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  0004d	8b 45 10	 mov	 eax, DWORD PTR _filename$[ebp]
  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00057	83 c4 08	 add	 esp, 8
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	89 45 ec	 mov	 DWORD PTR _tmpfile$[ebp], eax

; 94   : 		fputs(_itoa(getNumberOfEntries(database),tmp,10),tmpfile);

  00064	8b f4		 mov	 esi, esp
  00066	8b 45 ec	 mov	 eax, DWORD PTR _tmpfile$[ebp]
  00069	50		 push	 eax
  0006a	8b fc		 mov	 edi, esp
  0006c	6a 0a		 push	 10			; 0000000aH
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 08	 mov	 edx, DWORD PTR _database$[ebp]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 _getNumberOfEntries
  0007b	83 c4 04	 add	 esp, 4
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___itoa
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	3b fc		 cmp	 edi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	50		 push	 eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputs
  00096	83 c4 08	 add	 esp, 8
  00099	3b f4		 cmp	 esi, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 95   : 		fputs("\n",tmpfile);

  000a0	8b f4		 mov	 esi, esp
  000a2	8b 45 ec	 mov	 eax, DWORD PTR _tmpfile$[ebp]
  000a5	50		 push	 eax
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputs
  000b1	83 c4 08	 add	 esp, 8
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@outputData:

; 96   : 		while(database!=NULL)

  000bb	83 7d 08 00	 cmp	 DWORD PTR _database$[ebp], 0
  000bf	74 42		 je	 SHORT $LN3@outputData

; 97   : 		{
; 98   : 			fputs(database->word,tmpfile);

  000c1	8b f4		 mov	 esi, esp
  000c3	8b 45 ec	 mov	 eax, DWORD PTR _tmpfile$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _database$[ebp]
  000ca	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cc	52		 push	 edx
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputs
  000d3	83 c4 08	 add	 esp, 8
  000d6	3b f4		 cmp	 esi, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 99   : 			fputs("\n",tmpfile);

  000dd	8b f4		 mov	 esi, esp
  000df	8b 45 ec	 mov	 eax, DWORD PTR _tmpfile$[ebp]
  000e2	50		 push	 eax
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputs
  000ee	83 c4 08	 add	 esp, 8
  000f1	3b f4		 cmp	 esi, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 100  : 			database=database->next;

  000f8	8b 45 08	 mov	 eax, DWORD PTR _database$[ebp]
  000fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fe	89 4d 08	 mov	 DWORD PTR _database$[ebp], ecx

; 101  : 		}

  00101	eb b8		 jmp	 SHORT $LN2@outputData
$LN3@outputData:

; 102  : 	}
; 103  : 	fclose(tmpfile);

  00103	8b f4		 mov	 esi, esp
  00105	8b 45 ec	 mov	 eax, DWORD PTR _tmpfile$[ebp]
  00108	50		 push	 eax
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0010f	83 c4 04	 add	 esp, 4
  00112	3b f4		 cmp	 esi, esp
  00114	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 104  : 	free(tmp);

  00119	8b f4		 mov	 esi, esp
  0011b	8b 45 f8	 mov	 eax, DWORD PTR _tmp$[ebp]
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00125	83 c4 04	 add	 esp, 4
  00128	3b f4		 cmp	 esi, esp
  0012a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 105  : }

  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00138	3b ec		 cmp	 ebp, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
_outputDatabaseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _outputDatabaseScreen
_TEXT	SEGMENT
_database$ = 8						; size = 4
_outputDatabaseScreen PROC				; COMDAT

; 75   : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 76   : 	if(database!=NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _database$[ebp], 0
  00022	74 2b		 je	 SHORT $LN4@outputData
$LN3@outputData:

; 77   : 		while(database!=NULL)

  00024	83 7d 08 00	 cmp	 DWORD PTR _database$[ebp], 0
  00028	74 23		 je	 SHORT $LN2@outputData

; 78   : 		{
; 79   : 			puts(database->word);

  0002a	8b f4		 mov	 esi, esp
  0002c	8b 45 08	 mov	 eax, DWORD PTR _database$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__puts
  00038	83 c4 04	 add	 esp, 4
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 80   : 			database=database->next;

  00042	8b 45 08	 mov	 eax, DWORD PTR _database$[ebp]
  00045	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00048	89 4d 08	 mov	 DWORD PTR _database$[ebp], ecx

; 81   : 		}

  0004b	eb d7		 jmp	 SHORT $LN3@outputData
$LN2@outputData:

; 82   : 	else

  0004d	eb 17		 jmp	 SHORT $LN5@outputData
$LN4@outputData:

; 83   : 		puts("Brak wynikow!");

  0004f	8b f4		 mov	 esi, esp
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FIENMJNC@Brak?5wynikow?$CB?$AA@
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__puts
  0005c	83 c4 04	 add	 esp, 4
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@outputData:

; 84   : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_outputDatabaseScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _output
_TEXT	SEGMENT
_database$ = 8						; size = 4
_opt$ = 12						; size = 4
_fileptr$ = 16						; size = 4
_filename$ = 20						; size = 4
_output	PROC						; COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 59   : 	if(opt!=0)

  0001e	83 7d 0c 00	 cmp	 DWORD PTR _opt$[ebp], 0
  00022	74 68		 je	 SHORT $LN9@output

; 60   : 	{
; 61   : 		if((fileptr!=NULL) && (filename!=NULL))

  00024	83 7d 10 00	 cmp	 DWORD PTR _fileptr$[ebp], 0
  00028	74 1c		 je	 SHORT $LN7@output
  0002a	83 7d 14 00	 cmp	 DWORD PTR _filename$[ebp], 0
  0002e	74 16		 je	 SHORT $LN7@output

; 62   : 			outputDatabaseFile(database,fileptr,filename);

  00030	8b 45 14	 mov	 eax, DWORD PTR _filename$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 10	 mov	 ecx, DWORD PTR _fileptr$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR _database$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 _outputDatabaseFile
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	eb 46		 jmp	 SHORT $LN9@output
$LN7@output:

; 63   : 		else if(opt==1)

  00046	83 7d 0c 01	 cmp	 DWORD PTR _opt$[ebp], 1
  0004a	75 0e		 jne	 SHORT $LN5@output

; 64   : 			outputDatabaseScreen(database);

  0004c	8b 45 08	 mov	 eax, DWORD PTR _database$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _outputDatabaseScreen
  00055	83 c4 04	 add	 esp, 4
  00058	eb 32		 jmp	 SHORT $LN9@output
$LN5@output:

; 65   : 		else if(opt==2)

  0005a	83 7d 0c 02	 cmp	 DWORD PTR _opt$[ebp], 2
  0005e	75 2c		 jne	 SHORT $LN9@output

; 66   : 		{
; 67   : 			if((fileptr==NULL) || (filename==NULL))

  00060	83 7d 10 00	 cmp	 DWORD PTR _fileptr$[ebp], 0
  00064	74 06		 je	 SHORT $LN1@output
  00066	83 7d 14 00	 cmp	 DWORD PTR _filename$[ebp], 0
  0006a	75 14		 jne	 SHORT $LN2@output
$LN1@output:

; 68   : 				outputDatabaseFile(database,fileptr,filename);

  0006c	8b 45 14	 mov	 eax, DWORD PTR _filename$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 10	 mov	 ecx, DWORD PTR _fileptr$[ebp]
  00073	51		 push	 ecx
  00074	8b 55 08	 mov	 edx, DWORD PTR _database$[ebp]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 _outputDatabaseFile
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@output:

; 69   : 			outputDatabaseScreen(database);

  00080	8b 45 08	 mov	 eax, DWORD PTR _database$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _outputDatabaseScreen
  00089	83 c4 04	 add	 esp, 4
$LN9@output:

; 70   : 		}
; 71   : 	}
; 72   : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_output	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _findAllEntriesCounted
_TEXT	SEGMENT
_tmpcounter$ = -32					; size = 4
_tmpptr$ = -20						; size = 4
_results$ = -8						; size = 4
_wordtofind$ = 8					; size = 4
_database$ = 12						; size = 4
_counter$ = 16						; size = 4
_findAllEntriesCounted PROC				; COMDAT

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 39   : 	Entry * results=NULL, * tmpptr = NULL;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _results$[ebp], 0
  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tmpptr$[ebp], 0

; 40   : 	int tmpcounter=0;

  0002c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _tmpcounter$[ebp], 0

; 41   : 
; 42   : 	if(database==NULL)

  00033	83 7d 0c 00	 cmp	 DWORD PTR _database$[ebp], 0
  00037	75 04		 jne	 SHORT $LN5@findAllEnt

; 43   : 		return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 69		 jmp	 SHORT $LN7@findAllEnt
$LN5@findAllEnt:

; 44   : 	while(database!=NULL)

  0003d	83 7d 0c 00	 cmp	 DWORD PTR _database$[ebp], 0
  00041	74 60		 je	 SHORT $LN4@findAllEnt

; 45   : 	{
; 46   : 		if(strstr(database->word, wordtofind)!=NULL)

  00043	8b f4		 mov	 esi, esp
  00045	8b 45 08	 mov	 eax, DWORD PTR _wordtofind$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR _database$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	52		 push	 edx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  00055	83 c4 08	 add	 esp, 8
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	85 c0		 test	 eax, eax
  00061	74 20		 je	 SHORT $LN3@findAllEnt

; 47   : 			results=addEntryToList(newEntry(database->word,0),results);

  00063	8b 45 f8	 mov	 eax, DWORD PTR _results$[ebp]
  00066	50		 push	 eax
  00067	6a 00		 push	 0
  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _database$[ebp]
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 _newEntry
  00074	83 c4 08	 add	 esp, 8
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _addEntryToList
  0007d	83 c4 08	 add	 esp, 8
  00080	89 45 f8	 mov	 DWORD PTR _results$[ebp], eax
$LN3@findAllEnt:

; 48   : 		database=database->next;

  00083	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
  00086	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00089	89 4d 0c	 mov	 DWORD PTR _database$[ebp], ecx

; 49   : 		if(tmpcounter==counter)

  0008c	8b 45 e0	 mov	 eax, DWORD PTR _tmpcounter$[ebp]
  0008f	3b 45 10	 cmp	 eax, DWORD PTR _counter$[ebp]
  00092	75 04		 jne	 SHORT $LN2@findAllEnt

; 50   : 			break;

  00094	eb 0d		 jmp	 SHORT $LN4@findAllEnt
  00096	eb 09		 jmp	 SHORT $LN1@findAllEnt
$LN2@findAllEnt:

; 51   : 		else tmpcounter++;

  00098	8b 45 e0	 mov	 eax, DWORD PTR _tmpcounter$[ebp]
  0009b	83 c0 01	 add	 eax, 1
  0009e	89 45 e0	 mov	 DWORD PTR _tmpcounter$[ebp], eax
$LN1@findAllEnt:

; 52   : 	}

  000a1	eb 9a		 jmp	 SHORT $LN5@findAllEnt
$LN4@findAllEnt:

; 53   : 	return results;

  000a3	8b 45 f8	 mov	 eax, DWORD PTR _results$[ebp]
$LN7@findAllEnt:

; 54   : }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_findAllEntriesCounted ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _findAllEntries
_TEXT	SEGMENT
_tmpptr2$ = -32						; size = 4
_tmpptr$ = -20						; size = 4
_results$ = -8						; size = 4
_wordtofind$ = 8					; size = 4
_database$ = 12						; size = 4
_findAllEntries PROC					; COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 17   : 	Entry * results=NULL, * tmpptr=database, * tmpptr2=NULL;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _results$[ebp], 0
  00025	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
  00028	89 45 ec	 mov	 DWORD PTR _tmpptr$[ebp], eax
  0002b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _tmpptr2$[ebp], 0

; 18   : 
; 19   : 	if(database==NULL)

  00032	83 7d 0c 00	 cmp	 DWORD PTR _database$[ebp], 0
  00036	75 07		 jne	 SHORT $LN5@findAllEnt

; 20   : 		return NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 99 00 00 00	 jmp	 $LN7@findAllEnt
$LN5@findAllEnt:

; 21   : 	while(database!=NULL)

  0003f	83 7d 0c 00	 cmp	 DWORD PTR _database$[ebp], 0
  00043	74 63		 je	 SHORT $LN2@findAllEnt

; 22   : 	{
; 23   : 		if(strstr(database->word, wordtofind)!=NULL)

  00045	8b f4		 mov	 esi, esp
  00047	8b 45 08	 mov	 eax, DWORD PTR _wordtofind$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _database$[ebp]
  0004e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00050	52		 push	 edx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strstr
  00057	83 c4 08	 add	 esp, 8
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	85 c0		 test	 eax, eax
  00063	74 20		 je	 SHORT $LN3@findAllEnt

; 24   : 			results=addEntryToList(newEntry(database->word,0),results);

  00065	8b 45 f8	 mov	 eax, DWORD PTR _results$[ebp]
  00068	50		 push	 eax
  00069	6a 00		 push	 0
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _database$[ebp]
  0006e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 _newEntry
  00076	83 c4 08	 add	 esp, 8
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _addEntryToList
  0007f	83 c4 08	 add	 esp, 8
  00082	89 45 f8	 mov	 DWORD PTR _results$[ebp], eax
$LN3@findAllEnt:

; 25   : 		free(database->word);

  00085	8b f4		 mov	 esi, esp
  00087	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
  0008a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008c	51		 push	 ecx
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00093	83 c4 04	 add	 esp, 4
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 26   : 		database=database->next;		

  0009d	8b 45 0c	 mov	 eax, DWORD PTR _database$[ebp]
  000a0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a3	89 4d 0c	 mov	 DWORD PTR _database$[ebp], ecx

; 27   : 	}

  000a6	eb 97		 jmp	 SHORT $LN5@findAllEnt
$LN2@findAllEnt:

; 28   : 	while(tmpptr!=NULL)

  000a8	83 7d ec 00	 cmp	 DWORD PTR _tmpptr$[ebp], 0
  000ac	74 27		 je	 SHORT $LN1@findAllEnt

; 29   : 	{
; 30   : 		tmpptr2=tmpptr;		

  000ae	8b 45 ec	 mov	 eax, DWORD PTR _tmpptr$[ebp]
  000b1	89 45 e0	 mov	 DWORD PTR _tmpptr2$[ebp], eax

; 31   : 		tmpptr=tmpptr->next;

  000b4	8b 45 ec	 mov	 eax, DWORD PTR _tmpptr$[ebp]
  000b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ba	89 4d ec	 mov	 DWORD PTR _tmpptr$[ebp], ecx

; 32   : 		free(tmpptr2);

  000bd	8b f4		 mov	 esi, esp
  000bf	8b 45 e0	 mov	 eax, DWORD PTR _tmpptr2$[ebp]
  000c2	50		 push	 eax
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000c9	83 c4 04	 add	 esp, 4
  000cc	3b f4		 cmp	 esi, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 33   : 	}

  000d3	eb d3		 jmp	 SHORT $LN2@findAllEnt
$LN1@findAllEnt:

; 34   : 	return results;

  000d5	8b 45 f8	 mov	 eax, DWORD PTR _results$[ebp]
$LN7@findAllEnt:

; 35   : }

  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000e1	3b ec		 cmp	 ebp, esp
  000e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
_findAllEntries ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _getSearchedWord
_TEXT	SEGMENT
_tab$ = 8						; size = 4
_getSearchedWord PROC					; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 11   : 	return tab[2];

  0001e	b8 04 00 00 00	 mov	 eax, 4
  00023	d1 e0		 shl	 eax, 1
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _tab$[ebp]
  00028	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]

; 12   : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_getSearchedWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\paind_000\dysk google\grzesiek\dokumenty\studia\ja\projekt\hasla\dllc\program.c
;	COMDAT _GetNameOfFile
_TEXT	SEGMENT
_tab$ = 8						; size = 4
_GetNameOfFile PROC					; COMDAT

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 6    : 	return tab[3];

  0001e	b8 04 00 00 00	 mov	 eax, 4
  00023	6b c0 03	 imul	 eax, 3
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _tab$[ebp]
  00029	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]

; 7    : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_GetNameOfFile ENDP
_TEXT	ENDS
END
